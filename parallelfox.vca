SCCTEXT Version 4.0.0.2
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1252

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2XP193DS4
[CLASS] custom
[BASECLASS] custom
[OBJNAME] amanager
[START PROPERTIES]
Name = "amanager"
_memberdata =      403<VFPData><memberdata name="createparameterobject" display="CreateParameterObject"/><memberdata name="createparameterclause" display="CreateParameterClause"/><memberdata name="aarraycopy" display="aArrayCopy"/><memberdata name="copyarray" display="CopyArray"/><memberdata name="detecthyperthreading" display="DetectHyperThreading"/><memberdata name="lhyperthreading" display="lHyperThreading"/></VFPData>
lhyperthreading = .NULL.
[END PROPERTIES]
[START METHODS]
PROCEDURE copyarray
* Copy array to worker.
* ACOPY doesn't work when run from worker on array that is COM object property.
* Must pass array as parameter to worker.
Lparameters laArray

Debugout Time(0), Program()

Acopy(laArray, This.aArrayCopy)

ENDPROC
PROCEDURE createparameterclause
* Convert parameter object into variables
* Pass in parameter variables by reference ("out" variables)
Lparameters loParameters, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24, tPar25
Local lnPCount, lnParameter, lcParameter, lcParameterClause

Debugout Time(0), Program()

* Convert array to parameters and parameter clause
lcParameterClause = ""
lnPCount = loParameters.nPCount
For lnParameter = 1 to lnPCount
	lcParameter = "tPar" + Transform(lnParameter)
	
	* Build parameter clause
	If !Empty(lcParameterClause)
		lcParameterClause = lcParameterClause + ", "
	EndIf 
	If loParameters.IsArray(lcParameter)
		* Arrays have to be copied from object property and passed by reference
		loParameters.CopyArray(lcParameter, This)
		Dimension &lcParameter.[1]
		Acopy(This.aArrayCopy, &lcParameter)
		lcParameterClause = lcParameterClause + "@" + lcParameter
	Else
		&lcParameter = loParameters.&lcParameter
		lcParameterClause = lcParameterClause + lcParameter
	EndIf 
EndFor 

Return lcParameterClause


ENDPROC
PROCEDURE createparameterobject
* Convert parameters into parameter object
* Pass in all parameters by reference in case any are arrays.
Lparameters lnPCount, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24, tPar25
Local lnParameter, lcParameter, loParameters as Parameters of ParallelFox.vcx, lvValue

Debugout Time(0), Program()

loParameters = NewObject("Parameters","ParallelFox.vcx")
loParameters.nPCount = lnPCount
* AddProperty(loParameters, "nPCount", lnPCount)

* Create array of serialized parameters 
For lnParameter = 1 to lnPCount
	lcParameter = "tPar" + Transform(lnParameter)
	If Type(lcParameter, 1) = "A"
		* Arrays have to be copied to object property
		AddProperty(loParameters, lcParameter + "[1]")
		Acopy(&lcParameter, loParameters.&lcParameter)
	Else 
		AddProperty(loParameters, lcParameter)
		loParameters.&lcParameter = Evaluate(lcParameter)
	EndIf 
EndFor 
	
Return loParameters
ENDPROC
PROCEDURE detecthyperthreading
* Use WMI to determine if HyperThreading is turned on
* This only works on Windows XP SP3, Windows Server 2003, and later because
*	underlying Windows APIs were not added until those versions.
Local lcWMIFolder, loWMI, lcolProcessors, loProcessor

This.lHyperThreading = .F.

lcWMIFolder = Addbs(GetEnv("SystemRoot")) + "System32\WBEM\"
If Directory(lcWMIFolder)	&& make sure installed
	loWMI = GetObject("winmgmts:\\.\root\cimv2")
	lcolProcessors = loWMI.ExecQuery("Select * from Win32_Processor")
	For each loProcessor in lcolProcessors FoxObject
		If Type("loProcessor.NumberOfCores")<> "U" and Type("loProcessor.NumberOfLogicalProcessors")<> "U"
			* If logical processors > actual cores, HT must be turned on
			If loProcessor.NumberOfLogicalProcessors > loProcessor.NumberOfCores
				This.lHyperThreading = .T.
			EndIf 
		EndIf 
	EndFor 
EndIf 
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*copyarray Copy array.
*createparameterclause Create parameter clause from parameter object.
*createparameterobject 
*detecthyperthreading Detect if HyperThreading is turned on.
^aarraycopy[1,0] 
_memberdata XML Metadata for customizable properties
lhyperthreading Is .T. when HyperThreading is turned on.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] amanager

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2YT0NV2N3
[CLASS] custom
[BASECLASS] custom
[OBJNAME] command
[START PROPERTIES]
Name = "command"
_memberdata =      419<VFPData><memberdata name="ccommandtype" display="cCommandType"/><memberdata name="ccommand" display="cCommand"/><memberdata name="cclass" display="cClass"/><memberdata name="cmodule" display="cModule"/><memberdata name="oparameters" display="oParameters"/><memberdata name="nworker" display="nWorker"/><memberdata name="oevents" display="oEvents"/><memberdata name="cinapplication" display="cInApplication"/></VFPData>
cclass = 
ccommand = 
ccommandtype = 
cinapplication = 
cmodule = 
nworker = 0
oevents = .NULL.
oparameters = .NULL.
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
_memberdata XML Metadata for customizable properties
cclass Class containing command (if applicable).
ccommand Command.
ccommandtype Command type.
cinapplication Application containing class library.
cmodule Module/Class Library containing command (if applicable).
nworker Specifies which worker to run on.  0 means next available. Used to run a command on all workers.
oevents Events object.
oparameters Parameter object.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] command

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _3CV0I1GR4
[CLASS] custom
[BASECLASS] custom
[OBJNAME] errorhandler
[START PROPERTIES]
Name = "errorhandler"
_memberdata = <VFPData><memberdata name="handleerror" display="HandleError"/></VFPData>
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
* Default error handler 
* Unhandled errors may cause workers to crash when not in debug mode

On Error _Screen.oErrorHandler.HandleError(Error(), Sys(16), Lineno(1), Message(), Message(1))
ENDPROC
PROCEDURE handleerror
* Handle worker error and return to main process
Lparameters lnError, lcMethod, lnLine, lcMessage, lcCode
Local Worker as Worker
Worker = NewObject("Worker", "ParallelFox.vcx")

Worker.ReturnError(lnError, lcMethod, lnLine, lcMessage, lcCode)

* Exit current code containing error and return to command processor
Return to ProcessCommand 
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*handleerror Handle worker error.
_memberdata XML Metadata for customizable properties
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] errorhandler

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2YX0JA1AX
[CLASS] custom
[BASECLASS] custom
[OBJNAME] events
[START PROPERTIES]

Name = "events"
_memberdata =      581<VFPData><memberdata name="ncommands" display="nCommands"/><memberdata name="complete" display="Complete"/><memberdata name="updateprogress" display="UpdateProgress"/><memberdata name="returndata" display="ReturnData"/><memberdata name="returnerror" display="ReturnError"/><memberdata name="updatecommandcount" display="UpdateCommandCount"/><memberdata name="loadcursor" display="LoadCursor"/><memberdata name="returncursor" display="ReturnCursor"/><memberdata name="setdatasession" display="SetDataSession"/><memberdata name="getdatasession" display="GetDataSession"/></VFPData>
ncommands = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE complete
Lparameters lvReturn

Debugout Time(0), Program(), lvReturn

This.nCommands = This.nCommands - 1 

ENDPROC
PROCEDURE getdatasession
* Return data session ID of events object.

Return Set("Datasession")
ENDPROC
PROCEDURE loadcursor
* Load cursor from temp table.
Lparameters lcAlias, lcTempFile
Local lnCurrentArea, lcDBC

Debugout Time(0), Program(), lcAlias, lcTempFile

lnCurrentArea = Select()
lcDBC = Dbc()

Select * from (lcTempFile) ;
	into cursor (lcAlias) NoFilter ReadWrite

* Close/erase temp files
Set Database To (lcTempFile)
Close Databases 
Erase (lcTempFile + ".*")

Set Database To (lcDBC)
Select (lnCurrentArea)

* Fire event
This.ReturnCursor(lcAlias)

ENDPROC
PROCEDURE returncursor
* Fires when Worker.ReturnCursor() is called on worker and after cursor has been loaded.
Lparameters lcAlias

Debugout Time(0), Program(), lcAlias
ENDPROC
PROCEDURE returndata
* Fires when Worker.ReturnData() is called on worker.
Lparameters tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24, tPar25, tPar26
	
Debugout Time(0), Program(), tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24, tPar25, tPar26
ENDPROC
PROCEDURE returnerror
* Return error to main process
LPARAMETERS lnError, lcMethod, lnLine, lcMessage, lcCode

Debugout Time(0), Program(), lnError, lcMethod, lnLine, lcMessage, lcCode

This.nCommands = This.nCommands - 1 

ENDPROC
PROCEDURE setdatasession
* Set data session so events occur in same session as Parallel object.
* BindEvent does not cause data session switch, so this object needs to be in same datasession
Lparameters lnDataSession

Try 
	Set Datasession To (lnDataSession)
Catch
	* If data session not available, stay in current session
EndTry 
ENDPROC
PROCEDURE updatecommandcount
* Update number of commands currently running.
Lparameters llAllWorkers
Local lnCommands

If llAllWorkers
	lnCommands = _Screen.ParPoolMgr.nWorkerCount
Else
	lnCommands = 1
EndIf 

This.nCommands = This.nCommands + lnCommands

ENDPROC
PROCEDURE updateprogress
* Send progress update to main process
Lparameters lnProgress, lcMessage

Debugout Time(0), Program(), lnProgress, lcMessage
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*complete Fires when worker has finished executing command.
*getdatasession Return data session ID of events object.
*loadcursor Load cursor from temp table.
*returncursor Fires when Worker.ReturnCursor() is called on worker and after cursor has been loaded.
*returndata Fires when Worker.ReturnData() is called on worker.
*returnerror Return error to main process.
*setdatasession Set data session so events occur in same session as Parallel object.
*updatecommandcount Update number of commands currently running.
*updateprogress Fires when Worker.UpdateProgress() is called on worker.
_memberdata XML Metadata for customizable properties
ncommands Number of commands currently queued or running.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] events

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _3CV0J32BY
[CLASS] form
[BASECLASS] form
[OBJNAME] frmerrorlist
[START PROPERTIES]
AutoCenter = .T.
Caption = "ParallelFox Worker Errors"
DoCreate = .T.
Height = 480
Name = "frmerrorlist"
Width = 640
_memberdata = <VFPData><memberdata name="displayerror" display="DisplayError"/><memberdata name="cerrorlist" display="cErrorList"/></VFPData>
cerrorlist = 
[END PROPERTIES]
[START METHODS]
PROCEDURE displayerror
* Display error in list.
Lparameters lnError, lcMethod, lnLine, lcMessage, lcCode
Local lcErrorMsg

Text to lcErrorMsg TextMerge NoShow
Error: <<lnError>>
Message: <<lcMessage>>
Method: <<lcMethod>>
Line: <<lnLine>>
<<Replicate("-",100)>>

EndText 

ThisForm.cErrorList = ThisForm.cErrorList + lcErrorMsg
* ThisForm.edtErrorList.Value = ThisForm.edtErrorList.Value + lcErrorMsg
ThisForm.edtErrorList.Refresh()


ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
*displayerror Display error in list.
_memberdata XML Metadata for customizable properties
cerrorlist List of errors.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _3CV0J60T9
[CLASS] editbox
[BASECLASS] editbox
[OBJNAME] edtErrorList
[PARENT] frmerrorlist
[START PROPERTIES]
Anchor = 15
ControlSource = "Thisform.cErrorList"
Height = 478
Left = 1
Name = "edtErrorList"
ReadOnly = .T.
Top = 1
Width = 638
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] frmerrorlist
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2Z619GLX6
[CLASS] custom
[BASECLASS] custom
[OBJNAME] mainprocess
[START PROPERTIES]
Name = "mainprocess"
_memberdata = <VFPData><memberdata name="omainvfp" display="oMainVFP"/><memberdata name="isrunning" display="IsRunning"/><memberdata name="starttimer" display="StartTimer"/><memberdata name="otimer" display="oTimer"/></VFPData>
omainvfp = .NULL.
otimer = 
[END PROPERTIES]
[START METHODS]
PROCEDURE isrunning
* Check if main process is still running. If not, quit worker.
This.oTimer.Enabled = .f.

Debugout Time(0), Program()

* No need to test main process when in MTDLL
If _VFP.StartMode = 5
	Return .t.
EndIf 

Try 
	This.oMainVFP.Eval(1)
Catch
	Quit 
EndTry 

This.oTimer.Enabled = .t.
Return .t.
ENDPROC
PROCEDURE starttimer
* Start timer to periodically check that main process is still running.
Local loTimer as Timer

Debugout Time(0), Program()

loTimer = CreateObject("Timer")
BindEvent(loTimer, "Timer", This, "IsRunning")
loTimer.Interval = 60000	&& check every minute

This.oTimer = loTimer


ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*isrunning Check if main process is still running. If not, quit worker.
*starttimer Start timer to periodically check that main process is still running.
_memberdata XML Metadata for customizable properties
omainvfp Reference to _VFP object in main process.
otimer Timer to periodically check that main process is still running.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] mainprocess

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2XO1B7PVN
[CLASS] custom
[BASECLASS] custom
[OBJNAME] parallel
[START PROPERTIES]
Name = "parallel"
_events = NULL
_memberdata =      889<VFPData><memberdata name="do" display="Do"/><memberdata name="startworkers" display="StartWorkers"/><memberdata name="cpucount" display="CPUCount"/><memberdata name="setworkercount" display="SetWorkerCount"/><memberdata name="docmd" display="DoCmd"/><memberdata name="execscript" display="ExecScript"/><memberdata name="call" display="Call"/><memberdata name="bindevent" display="BindEvent"/><memberdata name="wait" display="Wait"/><memberdata name="_events" display="_Events"/><memberdata name="callmethod" display="CallMethod"/><memberdata name="stopworkers" display="StopWorkers"/><memberdata name="onerror" display="OnError"/><memberdata name="clearqueue" display="ClearQueue"/><memberdata name="setworkerclass" display="SetWorkerClass"/><memberdata name="detecthyperthreading" display="DetectHyperThreading"/><memberdata name="setmultithreaded" display="SetMultiThreaded"/></VFPData>
cpucount = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE Destroy
Debugout Time(0), Program()

UnBindEvents(This)

ENDPROC
PROCEDURE Init
* Instantiate parallel pool manager
If Type("_Screen.ParPoolMgr") <> "O" or IsNull(_Screen.ParPoolMgr)
	_Screen.NewObject("ParPoolMgr", "ParPoolMgr", "ParallelFox.vcx")
EndIf 

This.CPUCount = _Screen.ParPoolMgr.nCPUCount

This._Events = NewObject("Events", "ParallelFox.vcx")
This.BindEvent("ReturnError", _Screen.ParPoolMgr, "HandleError")

ENDPROC
PROCEDURE bindevent
* Bind to worker events
Lparameters cEvent, oEventHandler, cDelegate, nFlags

Debugout Time(0), Program(), cEvent, cDelegate

cEvent = Alltrim(cEvent)
nFlags = Evl(nFlags, 0)

* Unbind global error handler if overriding
If Upper(cEvent) = "RETURNERROR"
	UnBindEvents(This._Events, "ReturnError", _Screen.ParPoolMgr, "HandleError")
EndIf 

BindEvent(This._Events, cEvent, oEventHandler, cDelegate, nFlags)


ENDPROC
PROCEDURE call
* Execute program on worker
Lparameters cFunction, lAllWorkers, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24
Local loParameters

Debugout Time(0), Program(), cFunction, lAllWorkers, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24
	
This._Events.UpdateCommandCount(lAllWorkers)
	
loParameters = _Screen.ParPoolMgr.CreateParameterObject(Pcount()-2, @tPar1, @tPar2, @tPar3, @tPar4, ;
	@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
	@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
	@tPar19, @tPar20, @tPar21, @tPar22, @tPar23, @tPar24)
	
_Screen.ParPoolMgr.QueueCommand("Call", cFunction,,,,loParameters, lAllWorkers, This._Events)


ENDPROC
PROCEDURE callmethod
* Execute/call class method on worker.
Lparameters cMethod, cClassName, cModule, cInApplication, lAllWorkers, ;
	tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21
Local loParameters

Debugout Time(0), Program(), cMethod, cClassName, cModule, cInApplication, lAllWorkers, ;
	tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21
	
This._Events.UpdateCommandCount(lAllWorkers)
	
loParameters = _Screen.ParPoolMgr.CreateParameterObject(Pcount()-5, @tPar1, @tPar2, @tPar3, @tPar4, ;
	@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
	@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
	@tPar19, @tPar20, @tPar21)
	
_Screen.ParPoolMgr.QueueCommand("CallMethod", cMethod, cClassName, cModule, cInApplication, ;
	loParameters, lAllWorkers, This._Events)

ENDPROC
PROCEDURE clearqueue
* Remove all pending commands from queue.

Debugout Time(0), Program()

_Screen.ParPoolMgr.ClearQueue()
ENDPROC
PROCEDURE detecthyperthreading
* Returns .T. when HyperThreading is Enabled.
* Default value is NULL.  Detection is a little slow, so only run once.
If IsNull(_Screen.ParPoolMgr.lHyperThreading)
	_Screen.ParPoolMgr.DetectHyperThreading()
EndIf

Return _Screen.ParPoolMgr.lHyperThreading
ENDPROC
PROCEDURE do
* Execute program on worker
Lparameters cPRG, cInProgram, lAllWorkers, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23
Local loParameters

Debugout Time(0), Program(), cPRG, cInProgram, lAllWorkers, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23

This._Events.UpdateCommandCount(lAllWorkers)
	
loParameters = _Screen.ParPoolMgr.CreateParameterObject(Pcount()-3, @tPar1, @tPar2, @tPar3, @tPar4, ;
	@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
	@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
	@tPar19, @tPar20, @tPar21, @tPar22, @tPar23)
	
_Screen.ParPoolMgr.QueueCommand("Do", cPRG, cInProgram,,,loParameters, lAllWorkers, This._Events)

ENDPROC
PROCEDURE docmd
Lparameters cCommand, lAllWorkers

Debugout Time(0), Program(), cCommand, lAllWorkers

This._Events.UpdateCommandCount(lAllWorkers)
	
_Screen.ParPoolMgr.QueueCommand("DoCmd", cCommand,,,,, lAllWorkers, This._Events)
ENDPROC
PROCEDURE execscript
* Execute script on worker
Lparameters cScript, lAllWorkers, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24
Local loParameters

Debugout Time(0), Program(), "(Script)", lAllWorkers, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24
	
This._Events.UpdateCommandCount(lAllWorkers)
	
loParameters = _Screen.ParPoolMgr.CreateParameterObject(Pcount()-2, @tPar1, @tPar2, @tPar3, @tPar4, ;
	@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
	@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
	@tPar19, @tPar20, @tPar21, @tPar22, @tPar23, @tPar24)
	
_Screen.ParPoolMgr.QueueCommand("ExecScript", cScript,,,,loParameters, lAllWorkers, This._Events)


ENDPROC
PROCEDURE onerror
Lparameters cOnErrorCommand

Debugout Time(0), Program(), cOnErrorCommand

_Screen.ParPoolMgr.cOnError = cOnErrorCommand
ENDPROC
PROCEDURE setmultithreaded
* Set .T. to use in-process multithreaded DLL workers. Otherwise, out-of-process EXEs are used.
* Must be set before StartWorkers is called.
Lparameters llMTDLL

_Screen.ParPoolMgr.lMTDLL = llMTDLL

ENDPROC
PROCEDURE setworkerclass
* Change worker class from default. lcClass and lcLibrary are used in debug mode.
Lparameters cCOMProgID, cClass, cLibrary

Debugout Time(0), Program(), cCOMProgID, cClass, cLibrary

_Screen.ParPoolMgr.cWorkerCOMProgID = cCOMProgID
_Screen.ParPoolMgr.cWorkerClass = cClass
_Screen.ParPoolMgr.cWorkerLibrary = cLibrary
ENDPROC
PROCEDURE setworkercount
* Set number of workers. 
* Defaults to CPU count. 
* Set before starting workers.
Lparameters nWorkerCount, nTerminalServerCount

_Screen.ParPoolMgr.SetWorkerCount(nWorkerCount, nTerminalServerCount)


ENDPROC
PROCEDURE startworkers
* Start worker processes
* Same EXE is used for all workers
Lparameters cProcedureFile, cDirectory, lDebugMode

Debugout Time(0), Program(), cProcedureFile, cDirectory, lDebugMode

_Screen.ParPoolMgr.StartWorkers(cProcedureFile, cDirectory, lDebugMode)
ENDPROC
PROCEDURE stopworkers
* Stop worker processes
* Pass .T. to stop worker processes immediately. Otherwise, existing commands will finish first.
Lparameters lStopImmediately

Debugout Time(0), Program(), lStopImmediately

If lStopImmediately
	_Screen.ParPoolMgr.StopWorkers()
Else
	_Screen.ParPoolMgr.QueueCommand("StopWorkers")
EndIf 
ENDPROC
PROCEDURE wait
* Wait until workers have finished processing queued commands.
Lparameters lAllWorkers

Debugout Time(0), Program(), "Start"

Local lnKey
lnKey = 0
Do while .t.
	* Sleep() blocks worker processes, so use INKEY() to wait
	Try 
		lnKey = Inkey(.1, "H")
	Catch
		* INKEY() crashes intermittently. If that happens, use Chrsaw().
		lnKey = 0
		If Chrsaw(.1)
			lnKey = Inkey()
		EndIf 
	EndTry 	

	Do Case
	* ON Escape doesn't work during INKEY() and VFP can appear locked up.
	* CTRL+X will force exit from Wait.
	Case lnKey = 24
		Exit 
	* Wait for commands from current instance of Parallel object
	Case !lAllWorkers and !(This._Events.nCommands > 0 and _Screen.ParPoolMgr.nBusyWorkers > 0)
		Exit 
	* Wait for commands from all instances of Parallel object
	Case lAllWorkers and !(_Screen.ParPoolMgr.nBusyWorkers > 0 ;
			or (Type("_Screen.ParPoolMgr.CommandQueue.Count") = "N" and _Screen.ParPoolMgr.CommandQueue.Count > 0))
		Exit 
	EndCase 
EndDo 

Debugout Time(0), Program(), "Complete"
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*bindevent Bind to worker events: "Complete", "UpdateProgress", "ReturnData", "ReturnError".
*call Execute/call function on worker.
*callmethod Execute/call class method on worker.
*clearqueue Remove all pending commands from queue.
*detecthyperthreading Returns .T. when HyperThreading is enabled.
*do Execute program on worker.
*docmd Execute single command on worker.
*execscript Execute script on worker.
*onerror Set up global handler for worker errors. Available variables are nError, cMethod, nLine, cMessage, cCode. Example: Parallel.OnError("Do MyErrorHandler with nError, cMethod, nLine, cMessage, cCode")
*setmultithreaded Set .T. to use in-process multithreaded DLL workers. Otherwise, out-of-process EXEs are used.
*setworkerclass Change worker class from default. lcClass and lcLibrary are used in debug mode.
*setworkercount Set number of workers. Defaults to CPU count. Set before starting workers.
*startworkers Start worker processes.
*stopworkers Stop worker processes.
*wait Wait until workers have finished processing queued commands.
_events Use Parallel.BindEvent().
_memberdata XML Metadata for customizable properties
cpucount Number of logical processors on machine.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] parallel

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2YX10COEF
[CLASS] custom
[BASECLASS] custom
[OBJNAME] parameters
[START PROPERTIES]
Name = "parameters"
_memberdata = <VFPData><memberdata name="npcount" display="nPCount"/><memberdata name="isarray" display="IsArray"/><memberdata name="copyarray" display="CopyArray"/></VFPData>
npcount = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE copyarray
* Copy array to worker.
* ACOPY doesn't work when run from worker on array that is COM object property.
* Must pass array as parameter to worker.
Lparameters lcParameter, loManager as aManager of ParallelFox.vcx
Local lcArray
Local array laTemp[1]

lcArray = "This." + lcParameter
Acopy(&lcArray, laTemp)

loManager.CopyArray(@laTemp)
ENDPROC
PROCEDURE isarray
* Returns .T. if specified parameter is an array.
* Type("aArray", 1) does not work when called from worker.
Lparameters lcParameter
Local llIsArray

lcParameter = "This." + lcParameter
llIsArray = (Type(lcParameter, 1) = "A")

Return llIsArray

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*copyarray Copy array to worker.
*isarray Returns .T. if specified parameter is an array.
_memberdata XML Metadata for customizable properties
npcount Number of parameters.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] parameters

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2XP17XKBP
[CLASS] amanager
[CLASSLOC] parallelfox.vcx
[BASECLASS] custom
[OBJNAME] parpoolmgr
[START PROPERTIES]
Name = "parpoolmgr"
_memberdata =     1159<VFPData><memberdata name="ncpucount" display="nCPUCount"/><memberdata name="nworkercount" display="nWorkerCount"/><memberdata name="startworkers" display="StartWorkers"/><memberdata name="workers" display="Workers"/><memberdata name="nbusyworkers" display="nBusyWorkers"/><memberdata name="queuecommand" display="QueueCommand"/><memberdata name="processqueue" display="ProcessQueue"/><memberdata name="commandqueue" display="CommandQueue"/><memberdata name="ldebugmode" display="lDebugMode"/><memberdata name="stopworkers" display="StopWorkers"/><memberdata name="handleerror" display="HandleError"/><memberdata name="conerror" display="cOnError"/><memberdata name="clearqueue" display="ClearQueue"/><memberdata name="cworkercomprogid" display="cWorkerCOMProgID"/><memberdata name="cworkerclass" display="cWorkerClass"/><memberdata name="cworkerlibrary" display="cWorkerLibrary"/><memberdata name="nprocessing" display="nProcessing"/><memberdata name="setworkercount" display="SetWorkerCount"/><memberdata name="displayerrors" display="DisplayErrors"/><memberdata name="oerrorlist" display="oErrorList"/><memberdata name="lmtdll" display="lMTDLL"/></VFPData>
commandqueue = 
conerror = This.DisplayErrors(nError, cMethod, nLine, cMessage, cCode)
cworkerclass = WorkerMgr
cworkercomprogid = ParallelFox.WorkerMgr
cworkerlibrary = ParallelFox.vcx
ldebugmode = .F.
lmtdll = .F.
nbusyworkers = 0
ncpucount = 0
nprocessing = 0
nworkercount = 0
oerrorlist = .NULL.
workers = .NULL.
[END PROPERTIES]
[START PROTECTED]
ldebugmode
nprocessing
[END PROTECTED]
[START METHODS]
PROCEDURE Init
* Number of logical processors on machine.
This.nCPUCount = Evl(Val(GetEnv("NUMBER_OF_PROCESSORS")), 1)
This.SetWorkerCount(This.nCPUCount, 1)

This.Workers = CreateObject("Collection")
This.CommandQueue = CreateObject("Collection")

Return DoDefault()
ENDPROC
PROCEDURE clearqueue
* Remove all pending commands from queue.

Debugout Time(0), Program()

This.CommandQueue = NULL
This.CommandQueue = CreateObject("Collection")

This.nProcessing = 0
ENDPROC
PROCEDURE displayerrors
* Default error handler displays list of errors from workers.
Lparameters lnError, lcMethod, lnLine, lcMessage, lcCode

If Vartype(This.oErrorList) <> "O" or IsNull(This.oErrorList)
	This.oErrorList = NewObject("frmErrorList", "ParallelFox.vcx")
	This.oErrorList.Show()
EndIf 

This.oErrorList.DisplayError(lnError, lcMethod, lnLine, lcMessage, lcCode)
ENDPROC
PROCEDURE handleerror
* Global error handler. Set up with Parallel.OnError()
Lparameters nError, cMethod, nLine, cMessage, cCode
Local lcOnError

Debugout Time(0), Program(), nError, cMethod, nLine, cMessage, cCode

lcOnError = This.cOnError
&lcOnError

ENDPROC
PROCEDURE processqueue
Local lnCommands, lnCommand, loWorkerProxy as WorkerProxy of ParallelFox.vcx, ;
	lnCommandNum, llSendCommand, lnWorker

* This method can be interrupted and called again by worker events
* Make sure it completely finishes before calling again
* nProcessing=0 means ProcessQueue is not currently running and queue can be processed now
* nProcessing=1 means ProcessQueue is currently running
* nProcessing=2 means run ProcessQueue again at the end of the current run
* Need to do evaluation and assignment in single line of code so it doesn't get interrupted (hope this works)
If Iif(This.nProcessing > 0, ;
		This.WriteExpression("nProcessing", "2"), ;
		!This.WriteExpression("nProcessing", "1"))
	* Queue is currently being processed, so set flag to process again and return
	Debugout Time(0), Program(), "Already processing. Will process again."	
	Return
EndIf 

* Prevent error if run in the middle of CLEAR ALL
If Type("This.Workers.Count") = "U" or Type("This.CommandQueue.Count") = "U"
	? "Exiting ProcessQueue"
	Return 
EndIf 

* Release completed workers for more work
* Previously, this was done directly by WorkerProxy, 
*	but that allowed commands to be sent out of order
If This.nBusyWorkers > 0 
	For each loWorkerProxy in This.Workers FoxObject
		If loWorkerProxy.lBusy and loWorkerProxy.lComplete
			loWorkerProxy.lBusy = .f.
			loWorkerProxy.lComplete = .f.
			This.nBusyWorkers = This.nBusyWorkers - 1 
		EndIf 
	EndFor 
EndIf 

* Stop workers
If This.nBusyWorkers = 0 and This.CommandQueue.Count = 1 ;
		and Upper(This.CommandQueue(1).cCommandType) = "STOPWORKERS"
	This.StopWorkers()
	Return 
EndIf 

* Return if all workers busy
If This.nBusyWorkers >= This.Workers.Count or This.CommandQueue.Count = 0
	Debugout Time(0), Program(), "No workers or commands available", This.nBusyWorkers, This.CommandQueue.Count
	* Process again if necessary
	* Need to do evaluation and assignment in single line of code so it doesn't get interrupted
	If Iif(This.nProcessing > 1, ;
			This.WriteExpression("nProcessing", "0"), ;
			!This.WriteExpression("nProcessing", "0"))
		Debugout Time(0), Program(), "Processing again."	
		This.ProcessQueue()
	EndIf 
	Return
EndIf 

Debugout Time(0), Program(), "---- Process Queue Start ----"

lnCommands = This.CommandQueue.Count
lnCommandNum = 1
For lnCommand = 1 to lnCommands

	If This.nBusyWorkers >= This.Workers.Count or Upper(This.CommandQueue(lnCommandNum).cCommandType) = "STOPWORKERS"
		Exit 
	EndIf 
	
	llSendCommand = .f.
	
	* Which worker to run on can be specified.  0 means next available. Used to run a command on all workers.
	lnWorker = This.CommandQueue(lnCommandNum).nWorker
	If !Empty(lnWorker)
		loWorkerProxy = This.Workers(lnWorker)
		If !loWorkerProxy.lBusy
			loWorkerProxy.lLocked = .f.
			llSendCommand = .t.
		Else
			* If specific worker is busy, we'll try again next time
			* Lock worker so it can't be used by other commands
			loWorkerProxy.lLocked = .t.
			lnCommandNum = lnCommandNum + 1 
		EndIf 
	Else 
		* Find worker that is not busy or locked
		For each loWorkerProxy in This.Workers FoxObject
			If !loWorkerProxy.lBusy and !loWorkerProxy.lLocked
				llSendCommand = .t.
				Exit 
			EndIf 
		EndFor 
	EndIf 
	
	If llSendCommand 
		* Mark worker as busy
		loWorkerProxy.lBusy = .t.
		This.nBusyWorkers = This.nBusyWorkers + 1 
		* Send command to worker
		loWorkerProxy.SendCommand(This.CommandQueue(lnCommandNum))
		* Delete command from queue
		This.CommandQueue.Remove(lnCommandNum)
	EndIf 

EndFor 

Debugout Time(0), Program(), "---- Process Queue End ----"

* Process again if necessary
* Need to do evaluation and assignment in single line of code so it doesn't get interrupted
If Iif(This.nProcessing > 1, ;
		This.WriteExpression("nProcessing", "0"), ;
		!This.WriteExpression("nProcessing", "0"))
	Debugout Time(0), Program(), "Processing again."	
	This.ProcessQueue()
EndIf 

ENDPROC
PROCEDURE queuecommand
* Add command to queue.
Lparameters lcCommandType, lcCommand, lcClass, lcModule, lcInApplication, ;
	loParameters, llAllWorkers, loEvents
Local loCommand as Command of ParallelFox.vcx, lnWorker, lnWorkerCnt

Debugout Time(0), Program(), lcCommandType, lcCommand, lcClass, lcModule, ;
	lcInApplication, llAllWorkers

If llAllWorkers
	* Queue command for all workers
	lnWorkerCnt = This.nWorkerCount
Else
	* Queue for next available worker
	lnWorkerCnt = 1
EndIf 

For lnWorker = 1 to lnWorkerCnt 
	* Create command object
	loCommand = NewObject("Command", "ParallelFox.vcx")
	loCommand.cCommandType = Evl(lcCommandType, "")
	loCommand.cCommand = Evl(lcCommand, "")
	loCommand.cClass = Evl(lcClass, "")
	loCommand.cModule = Evl(lcModule, "")
	loCommand.cInApplication = Evl(lcInApplication, "")
	loCommand.oParameters = loParameters
	loCommand.oEvents = loEvents
	If llAllWorkers
		loCommand.nWorker = lnWorker
	EndIf 
	* Add to queue
	This.CommandQueue.Add(loCommand)
EndFor 

This.ProcessQueue()
 
ENDPROC
PROCEDURE setworkercount
* Set number of workers. 
* Defaults to CPU count. 
* Set before starting workers.
Lparameters lnWorkerCount, lnTerminalServerCount

Debugout Time(0), Program(), lnWorkerCount, lnTerminalServerCount

lnWorkerCount = Evl(lnWorkerCount, 0)
lnTerminalServerCount = Evl(lnTerminalServerCount, 0)

If Bittest(Val(Os(10)), 4) and !Bittest(Val(Os(10)), 8)	&& Terminal Server with multiple users
	This.nWorkerCount = Max(Round(lnTerminalServerCount, 0), 1)
Else 
	This.nWorkerCount = Max(Round(lnWorkerCount, 0), 1)
EndIf 

ENDPROC
PROCEDURE startworkers
* Start worker processes
* Same EXE is used for all workers
Lparameters lcProcedureFile, lcDirectory, llDebugMode
Local lnWorker, loWorkerProxy as WorkerProxy of ParallelFox.vcx

Debugout Time(0), Program(), lcProcedureFile, lcDirectory, llDebugMode

If This.Workers.Count > 0
	Assert .f. Message "Workers already started."
	Return
EndIf 

This.lDebugMode = llDebugMode

For lnWorker = 1 to This.nWorkerCount
	loWorkerProxy = NewObject("WorkerProxy", "ParallelFox.vcx", "", lcProcedureFile, lcDirectory, llDebugMode, lnWorker, This.lMTDLL)
	ComArray(loWorkerProxy, 11)
	This.Workers.Add(loWorkerProxy)
EndFor 

ENDPROC
PROCEDURE stopworkers
* Stop worker processes
Local loWorkerProxy as WorkerProxy of ParallelFox.vcx

Debugout Time(0), Program()

* Release workers
For each loWorkerProxy in This.Workers FoxObject
	loWorkerProxy.StopWorker()
EndFor 

This.Workers = NULL
This.Workers = CreateObject("Collection")
This.nBusyWorkers = 0

* Clear command queue
This.ClearQueue()

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*clearqueue Remove all pending commands from queue.
*displayerrors Default error handler displays list of errors from workers.
*handleerror Global Error Handler.
*processqueue Process command queue.
*queuecommand Add command to queue.
*setworkercount Sets number for workers.
*startworkers Start worker processes.
*stopworkers Stop worker processes.
commandqueue Command queue collection.
conerror On Error command.
cworkerclass Worker class name (used in debug mode).
cworkercomprogid COM ProgID for worker class.
cworkerlibrary Worker class library (used in debug mode).
ldebugmode Start workers in Debug mode.
lmtdll Set .T. to use in-process multithreaded DLL workers. Otherwise, out-of-process EXEs are used.
nbusyworkers Number of workers currently processing commands.
ncpucount Number of logical processors on machine.
nprocessing Number of times ProcessQueue has been called.
nworkercount Number of workers. Defaults to CPU count.
oerrorlist Reference to error list form.
workers Workers collection.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] parpoolmgr

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2XR0NRM8S
[CLASS] timer
[BASECLASS] timer
[OBJNAME] tmrcommand
[START PROPERTIES]
Enabled = .F.
Height = 23
Interval = 1
Name = "tmrcommand"
Width = 23
_memberdata = <VFPData><memberdata name="processcommand" display="ProcessCommand"/><memberdata name="lprocessed" display="lProcessed"/><memberdata name="omanager" display="oManager"/></VFPData>
lprocessed = 
omanager = .NULL.
[END PROPERTIES]
[START METHODS]
PROCEDURE Timer
* Worker Command timer
* Timer is used to process command so main thread does not
*	wait on command to complete.
* Timer is enabled for each command and only fires once.
Local loManager

This.Enabled = .f.
Doevents 
* Timer can fire more than once before it is disabled.
* Doevents usually prevents this from happening, but this code ensures it.
If This.lProcessed
	Return 
EndIf 
This.lProcessed = .t.

* Hold reference to manager for minimum time to help avoid dangling objects
loManager = This.oManager
This.oManager = NULL
loManager.ProcessCommand() 

ENDPROC
PROCEDURE processcommand
* Process current command
Lparameters loManager

This.oManager = loManager
This.lProcessed = .f.
This.Enabled = .t.

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*processcommand Process current command.
_memberdata XML Metadata for customizable properties
lprocessed Is .T. if command already processed.
omanager Manager class that processes command.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] tmrcommand

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2XO1B8M8D
[CLASS] custom
[BASECLASS] custom
[OBJNAME] worker
[START PROPERTIES]
Name = "worker"
_lastprogressupdate = 0
_memberdata =      719<VFPData><memberdata name="updateprogress" display="UpdateProgress"/><memberdata name="progressinterval" display="ProgressInterval"/><memberdata name="_lastprogressupdate" display="_LastProgressUpdate"/><memberdata name="returndata" display="ReturnData"/><memberdata name="startcriticalsection" display="StartCriticalSection"/><memberdata name="endcriticalsection" display="EndCriticalSection"/><memberdata name="_criticalsections" display="_CriticalSections"/><memberdata name="sleep" display="Sleep"/><memberdata name="cpucount" display="CPUCount"/><memberdata name="returnerror" display="ReturnError"/><memberdata name="isworker" display="IsWorker"/><memberdata name="returncursor" display="ReturnCursor"/></VFPData>
cpucount = 0
progressinterval = 1
[END PROPERTIES]
[START PROTECTED]
_lastprogressupdate
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* End any active critical sections
Local lnRows, lnRow, lnhMutex 

Debugout Time(0), Program()

lnRows = Alen(This._CriticalSections, 1)
For lnRow = 1 to lnRows
	lnhMutex = This._CriticalSections[lnRow,2]
	If !Empty(lnhMutex)
		ReleaseMutex(lnhMutex)
	EndIf 
EndFor 


ENDPROC
PROCEDURE Init
* Number of logical processors on machine.
This.CPUCount = Evl(Val(GetEnv("NUMBER_OF_PROCESSORS")), 1)

* Load DLLs
DECLARE Sleep IN kernel32 INTEGER dwMilliseconds

DECLARE INTEGER CreateMutex IN kernel32;
    INTEGER lpMutexAttributes,;
    INTEGER bInitialOwner,;
    STRING  lpName
    
DECLARE INTEGER WaitForSingleObject IN kernel32;
    INTEGER hHandle,;
    INTEGER dwMilliseconds
   
DECLARE INTEGER ReleaseMutex IN kernel32;
    INTEGER hMutex


ENDPROC
PROCEDURE endcriticalsection
* End Critical Section of code.
Lparameters cCriticalSectionName
Local lnhMutex, lnRow

Debugout Time(0), Program(), cCriticalSectionName

* Find and release mutex
lnRow = Ascan(This._CriticalSections, cCriticalSectionName, 1, 0, 1, 8)
If lnRow <> 0
	lnhMutex = This._CriticalSections[lnRow,2]
	ReleaseMutex(lnhMutex)

	* Remove from array
	Adel(This._CriticalSections, lnRow)
EndIf 
ENDPROC
PROCEDURE isworker
* Returns .T. if currently running in Worker process.

Return Type("_Screen.oWorkerEvents") = "O"
ENDPROC
PROCEDURE returncursor
* Return cursor to main process.
Lparameters cAlias
Local cDirectory, lcTempName, lcTempFile, lnCurrentArea, lcDBC

cAlias = Evl(cAlias, Alias())
cDirectory = Evl(cDirectory, Sys(2023))

Do while .t.
	* Sys(2015) may actually return the same value in separate processes
	* Add ThreadID to the name to make sure it is unique across all workers
	lcTempName = Sys(2015) + "_" + Transform(_VFP.ThreadId)
	lcTempFile = Addbs(cDirectory) + lcTempName
	If !File(lcTempFile + ".dbf") and !File(lcTempFile + ".dbc")
		Exit
	EndIf
EndDo 

* Create database to support long field names
lcDBC = Dbc()
If !DBused(lcDBC)	
	* Full path may not work if DBC is compiled into EXE/APP
	lcDBC = JustStem(JustFname(lcDBC))
EndIf 
lnCurrentArea = Select()
Create Database (lcTempFile)

* Copy cursor to temp table
Select (cAlias)
Copy To (lcTempFile) Database (lcTempFile)

Set Database To (lcTempFile)
Close Databases 
Set Database To (lcDBC)
Select (lnCurrentArea)

If _Screen.oMainProcess.IsRunning() and Type("_Screen.oWorkerEvents.Name") = "C"
	_Screen.oWorkerEvents.LoadCursor(cAlias, lcTempFile)
EndIf 

ENDPROC
PROCEDURE returndata
* Return data to main process.
* BindEvent() does not work with parameters passed by reference, so all parameters must be
*	passed by value.  This prevents arrays from being supported.
Lparameters tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24, tPar25, tPar26
Local lnPCount, lnParameter, lcParameter, lcParameterClause

Debugout Time(0), Program(), tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24, tPar25, tPar26

* Build parameter clause
lcParameterClause = ""
lnPCount = Pcount()
For lnParameter = 1 to lnPCount
	* Pass parameters by reference in case passed by reference to this method
	lcParameter = "tPar" + Transform(lnParameter)
	If !Empty(lcParameterClause)
		lcParameterClause = lcParameterClause + ", "
	EndIf 
	lcParameterClause = lcParameterClause + lcParameter
EndFor 

If _Screen.oMainProcess.IsRunning() and Type("_Screen.oWorkerEvents.Name") = "C"
	_Screen.oWorkerEvents.ReturnData(&lcParameterClause)
EndIf 

ENDPROC
PROCEDURE returnerror
* Return error to main process.
Lparameters nError, cMethod, nLine, cMessage, cCode

Debugout Time(0), Program(), nError, cMethod, nLine, cMessage, cCode

If _Screen.oMainProcess.IsRunning() and Type("_Screen.oWorkerEvents.Name") = "C"
	_Screen.oWorkerEvents.ReturnError(nError, cMethod, nLine, cMessage, cCode)
EndIf 

ENDPROC
PROCEDURE sleep
* Pause execution if machine contains the specified number CPUs or fewer. 
* Omit lnCPUCount (or pass 0) to pause regardless of CPUs.
Lparameters nMilliseconds, nCPUCount

nMilliseconds = Evl(nMilliseconds, 0)
If Empty(nCPUCount) or This.CPUCount <= nCPUCount
	Debugout Time(0), Program(), nMilliseconds
	Sleep(nMilliseconds)
EndIf 
ENDPROC
PROCEDURE startcriticalsection
* Start Critical Section of code. Use a unique (but not random) name for each critical section.
Lparameters cCriticalSectionName
Local lnhMutex, lnHandleCount

#DEFINE INFINITE 0xFFFFFFFF

Debugout Time(0), Program(), cCriticalSectionName

lnhMutex = CreateMutex(0, 0, cCriticalSectionName)

* Wait for other processes to finish critical section
WaitForSingleObject(lnhMutex, INFINITE)

* Add handle to array so we can access it by name
lnHandleCount = Alen(This._CriticalSections, 1)
If lnHandleCount = 1 and Empty(This._CriticalSections[1,1])
	lnHandleCount = 1
Else
	lnHandleCount = lnHandleCount + 1 
EndIf 
Dimension This._CriticalSections[lnHandleCount,2]
This._CriticalSections[lnHandleCount,1] = cCriticalSectionName
This._CriticalSections[lnHandleCount,2] = lnhMutex

ENDPROC
PROCEDURE updateprogress
* Send progress update to main process
* Pass .T. to llForceUpdate to disregard Worker.ProgressInterval.
Lparameters nProgress, cMessage, lForceUpdate
Local lnSeconds

Debugout Time(0), Program(), nProgress, cMessage, lForceUpdate

lnSeconds = Seconds() - This._LastProgressUpdate
If lForceUpdate or lnSeconds < 0 or lnSeconds >= This.ProgressInterval
	If _Screen.oMainProcess.IsRunning() and Type("_Screen.oWorkerEvents.Name") = "C"
		_Screen.oWorkerEvents.UpdateProgress(nProgress, cMessage)
	EndIf 
	This._LastProgressUpdate = Seconds()
EndIf 

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*endcriticalsection End Critical Section of code.
*isworker Returns .T. if currently running in Worker process.
*returncursor Return cursor to main process.
*returndata Return data to main process. Due to limitations with VFP BindEvent(), arrays are not supported and cannot be returned.
*returnerror Return error to main process.
*sleep Pause execution if machine contains the specified number CPUs or fewer. Omit lnCPUCount (or pass 0) to pause regardless of CPUs.
*startcriticalsection Start Critical Section of code. Use a unique (but not random) name for each critical section.
*updateprogress Send progress update to main process. Pass .T. to llForceUpdate to disregard Worker.ProgressInterval.
^_criticalsections[1,2] Use Worker.StartCriticalSection().
_lastprogressupdate Time of last progress update sent to main process.
_memberdata XML Metadata for customizable properties
cpucount Number of logical processors on machine.
progressinterval Minimum number of seconds between progress updates (default is 1 second).
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] worker

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2XO1B8UVB
[CLASS] amanager
[CLASSLOC] parallelfox.vcx
[BASECLASS] custom
[OBJNAME] workermgr
[START PROPERTIES]
Name = "workermgr"
_memberdata =     1077<VFPData><memberdata name="deserializeparameters" display="DeserializeParameters"/><memberdata name="instantiateipc" display="InstantiateIPC"/><memberdata name="instantiatejson" display="InstantiateJSON"/><memberdata name="processmessage" display="ProcessMessage"/><memberdata name="registerworker" display="RegisterWorker"/><memberdata name="hwndmain" display="hWndMain"/><memberdata name="ocmdtimer" display="oCmdTimer"/><memberdata name="processcommand" display="ProcessCommand"/><memberdata name="ocommand" display="oCommand"/><memberdata name="createcommandobject" display="CreateCommandObject"/><memberdata name="execscript" display="ExecScript"/><memberdata name="call" display="Call"/><memberdata name="sendcommand" display="SendCommand"/><memberdata name="docmd" display="DoCmd"/><memberdata name="callmethod" display="CallMethod"/><memberdata name="do" display="Do"/><memberdata name="setmainprocess" display="SetMainProcess"/><memberdata name="setworkerevents" display="SetWorkerEvents"/><memberdata name="startmtcommandloop" display="StartMTCommandLoop"/></VFPData>
ocmdtimer = .NULL.
ocommand = .NULL.
[END PROPERTIES]
[START PROTECTED]
call
callmethod
do
execscript
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Make sure worker is closed
Debugout Time(0), Program()

If _VFP.StartMode <> 5
	Quit
EndIf 

ENDPROC
PROCEDURE Init
_VFP.Caption = "ParallelFox Worker"
* Set Unattended mode unless in debug mode
* Make sure an error handler is in place on worker or displaying UI 
*	can cause worker to crash.
If _VFP.StartMode > 1
	Sys(2335,0)
	* Default error handler
	_Screen.NewObject("oErrorHandler", "ErrorHandler", "ParallelFox.vcx")
EndIf 
Set TablePrompt Off
If _VFP.StartMode <> 5
	This.oCmdTimer = NewObject("tmrCommand", "ParallelFox.vcx")
EndIf 

StrToFile(Transform(Datetime()) + ": " + Program() + Chr(13), "MTLog.txt", 1)

Return DoDefault()
ENDPROC
PROCEDURE call
* Execute/call function on worker
Lparameters lcFunction, loParameters
Local tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24, tPar25
Local lcParameterClause, lcFunctionCall

lcParameterClause = This.CreateParameterClause(loParameters, @tPar1, @tPar2, @tPar3, @tPar4, ;
	@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
	@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
	@tPar19, @tPar20, @tPar21, @tPar22, @tPar23, @tPar24, @tPar25)

Debugout Time(0), Program(), lcFunction, lcParameterClause 
	
lcFunctionCall = Alltrim(lcFunction)+ "(" + lcParameterClause + ")"
Return &lcFunctionCall


ENDPROC
PROCEDURE callmethod
* Execute/call class method on worker.
Lparameters lcMethod, lcClassName, lcModule, lcInApplication, loParameters
Local tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24, tPar25
Local lcParameterClause, lcMethodCall, loObject
	
lcParameterClause = This.CreateParameterClause(loParameters, @tPar1, @tPar2, @tPar3, @tPar4, ;
	@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
	@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
	@tPar19, @tPar20, @tPar21, @tPar22, @tPar23, @tPar24, @tPar25)

Debugout Time(0), Program(), lcMethod, lcClassName, lcModule, lcInApplication, lcParameterClause 
	
loObject = NewObject(lcClassName, lcModule, lcInApplication)
lcMethodCall = Alltrim(lcMethod)+ "(" + lcParameterClause + ")"
Return loObject.&lcMethodCall


ENDPROC
PROCEDURE do
* Execute program on worker
Lparameters lcPRG, lcInProgram, loParameters
Local tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24, tPar25
Local lcParameterClause

If loParameters.nPCount > 0
	lcParameterClause = This.CreateParameterClause(loParameters, @tPar1, @tPar2, @tPar3, @tPar4, ;
		@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
		@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
		@tPar19, @tPar20, @tPar21, @tPar22, @tPar23, @tPar24, @tPar25)
	* DO passes all parameters by reference, so strip out "@" to avoid syntax error
	lcParameterClause = Chrtran(lcParameterClause, "@", "")
	Debugout Time(0), Program(), lcPRG, lcInProgram, lcParameterClause 	
	Do (lcPRG) in (lcInProgram) with &lcParameterClause
Else 
	Debugout Time(0), Program(), lcPRG, lcInProgram
	Do (lcPRG) in (lcInProgram)
EndIf 

* No return value from DO command, so always .T.
ENDPROC
PROCEDURE docmd
Lparameters lcCommand

Debugout Time(0), Program(), lcCommand

Return _VFP.DoCmd(lcCommand)
ENDPROC
PROCEDURE execscript
* Execute script on worker
Lparameters lcScript, loParameters
Local tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
	tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
	tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
	tPar21, tPar22, tPar23, tPar24, tPar25
Local lcParameterClause
	
If loParameters.nPCount > 0
	lcParameterClause = This.CreateParameterClause(loParameters, @tPar1, @tPar2, @tPar3, @tPar4, ;
		@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
		@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
		@tPar19, @tPar20, @tPar21, @tPar22, @tPar23, @tPar24, @tPar25)
	Debugout Time(0), Program(), "(Script)", lcParameterClause 
	Return ExecScript(lcScript, &lcParameterClause)
Else
	Debugout Time(0), Program(), "(Script)"
	Return ExecScript(lcScript)
EndIf 


ENDPROC
PROCEDURE processcommand
* Process Command
Local loCommand as Command of ParallelFox.vcx, lcCommandType, lvReturn
loCommand = This.oCommand	&& for Intellisense

Assert !IsNull(loCommand) Message Program() + " Command object is NULL"

Debugout Time(0), Program(), loCommand.cCommandType, loCommand.cCommand, ;
	loCommand.cClass, loCommand.cModule

lcCommandType = Upper(Alltrim(loCommand.cCommandType))
Do Case
Case lcCommandType == "DOCMD"
	lvReturn = This.DoCmd(loCommand.cCommand)
Case lcCommandType == "DO"
	lvReturn = This.Do(loCommand.cCommand, loCommand.cClass, loCommand.oParameters)
Case lcCommandType == "CALL"
	lvReturn = This.Call(loCommand.cCommand, loCommand.oParameters)
Case lcCommandType == "CALLMETHOD"
	lvReturn = This.CallMethod(loCommand.cCommand, loCommand.cClass, loCommand.cModule, loCommand.cInApplication, loCommand.oParameters)
Case lcCommandType == "EXECSCRIPT"
	lvReturn = This.ExecScript(loCommand.cCommand, loCommand.oParameters)
Otherwise

EndCase

* Fire Complete event
If _Screen.oMainProcess.IsRunning() and Type("_Screen.oWorkerEvents.Name") = "C"
	_Screen.oWorkerEvents.Complete(lvReturn)
EndIf 

ENDPROC
PROCEDURE sendcommand
* Send command to worker
Lparameters loCommand as Command of ParallelFox.vcx

Debugout Time(0), Program(), loCommand.cCommandType, loCommand.cCommand, ;
	loCommand.cClass, loCommand.cModule

This.oCommand = loCommand

* Timer is used to start command without blocking main process
This.oCmdTimer.ProcessCommand(This)
ENDPROC
PROCEDURE setmainprocess
* Set reference to main process.
Lparameters loMainVFP, lcWorkerApp
Local loMainProcess as MainProcess of ParallelFox.vcx

StrToFile(Transform(Datetime()) + ": " + Program() + " - " + Transform(lcWorkerApp) + Chr(13), "MTLog.txt", 1)

If VarType(_Screen.oMainProcess) = "U"
	_Screen.AddProperty("oMainProcess", NULL)
EndIf 

StrToFile(Transform(Datetime()) + ": lcWorkerApp " + lcWorkerApp + Chr(13), "MTLog.txt", 1)
loMainProcess = NewObject("MainProcess", This.ClassLibrary, lcWorkerApp)
loMainProcess.oMainVFP = loMainVFP
loMainProcess.StartTimer()
_Screen.oMainProcess = loMainProcess

ENDPROC
PROCEDURE setworkerevents
* Set reference to worker events object.
Lparameters loWorkerEvents

If VarType(_Screen.oWorkerEvents) = "U"
	_Screen.AddProperty("oWorkerEvents", NULL)
EndIf 

_Screen.oWorkerEvents = loWorkerEvents
ENDPROC
PROCEDURE startmtcommandloop
* Start command loop for MTDLL
* When using MTDLL workers, the thread will shutdown as soon as program is complete
* So, we have to use a loop to keep program alive and fetch commands from main thread.
Lparameters loWorkerProxy as WorkerProxy of ParallelFox.vcx
Local lnEventHandle, lcScript, llExit, lnWaitStatus

#DEFINE INFINITE 0xFFFFFFFF
#DEFINE WAIT_TIMEOUT 0x00000102

DECLARE INTEGER WaitForSingleObject IN kernel32;
    INTEGER hHandle,;
    INTEGER dwMilliseconds

lnEventHandle = loWorkerProxy.nMTEventHandle

This.SetWorkerEvents(loWorkerProxy.oEvents)

StrToFile(Transform(Datetime()) + " - " + Transform(lnEventHandle) + ": " + Program() + Chr(13), "MTLog.txt", 1)

llExit = .f.
Do while .t.
	
	* Wait until main thread sends event that a command is ready to process
	StrToFile(Transform(Datetime()) + " - " + Transform(lnEventHandle) + ": Waiting for Event" + Chr(13), "MTLog.txt", 1)
	lnWaitStatus = WaitForSingleObject(lnEventHandle, 10000)
	If lnWaitStatus <> 0
		* Zero means event fired
		* If timeout, check and see if proxy still good
		If lnWaitStatus = WAIT_TIMEOUT and Type("loWorkerProxy.Name") = "C"
			StrToFile(Transform(Datetime()) + " - " + Transform(lnEventHandle) + ": Wait Timeout " + Chr(13), "MTLog.txt", 1)
			Loop 
		Else 
			* Otherwise, something went wrong, so exit
			StrToFile(Transform(Datetime()) + " - " + Transform(lnEventHandle) + ": Wait Status Problem " + Transform(lnWaitStatus) + Chr(13), "MTLog.txt", 1)
			Exit 
		EndIf 
	EndIf 

	StrToFile(Transform(Datetime()) + " - " + Transform(lnEventHandle) + ": Event Received" + Chr(13), "MTLog.txt", 1)

	Try
		lcScript = loWorkerProxy.cMTScript
		This.oCommand = loWorkerProxy.oMTCommand
	Catch 
		* If can't access worker proxy object or commands, exit	
		llExit = .t.
	EndTry 	
	If llExit
		Exit
	EndIf 
	
	* Exit if stop workers command sent
	If Upper(lcScript) = "STOPWORKER"
		StrToFile(Transform(Datetime()) + " - " + Transform(lnEventHandle) + ": STOPWORKER Command" + Chr(13), "MTLog.txt", 1)
		Exit 
	EndIf 
	
	* Process command
	StrToFile(Transform(Datetime()) + " - " + Transform(lnEventHandle) + ": Processing Command" + Chr(13), "MTLog.txt", 1)
	This.ProcessCommand()
	StrToFile(Transform(Datetime()) + " - " + Transform(lnEventHandle) + ": Processing Complete" + Chr(13), "MTLog.txt", 1)

EndDo 

StrToFile(Transform(Datetime()) + " - " + Transform(lnEventHandle) + ": Exited Loop" + Chr(13), "MTLog.txt", 1)

This.oCommand = NULL

StrToFile(Transform(Datetime()) + " - " + Transform(lnEventHandle) + ": This.oCommand Released" + Chr(13), "MTLog.txt", 1)

This.SetWorkerEvents(NULL)

StrToFile(Transform(Datetime()) + " - " + Transform(lnEventHandle) + ": SetWorkerEvents(NULL)" + Chr(13), "MTLog.txt", 1)


ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*call Execute/call function on worker.
*callmethod Execute/call class method on worker.
*do Execute program on worker.
*docmd Execute single command on worker.
*execscript Execute script on worker.
*processcommand Process command.
*sendcommand Send command to worker process.
*setmainprocess Set reference to main process.
*setworkerevents Set reference to worker events object.
*startmtcommandloop Start command loop for MTDLL
ocmdtimer Timer used to start command asynchronously.
ocommand Command object.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] workermgr

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2XO1BA4B4
[CLASS] custom
[BASECLASS] custom
[OBJNAME] workerproxy
[START PROPERTIES]
Name = "workerproxy"
_memberdata =      983<VFPData><memberdata name="lbusy" display="lBusy"/><memberdata name="oworker" display="oWorker"/><memberdata name="sendcommand" display="SendCommand"/><memberdata name="complete" display="Complete"/><memberdata name="llocked" display="lLocked"/><memberdata name="ldebugmode" display="lDebugMode"/><memberdata name="stopworker" display="StopWorker"/><memberdata name="handleerror" display="HandleError"/><memberdata name="oevents" display="oEvents"/><memberdata name="oapplication" display="oApplication"/><memberdata name="lcomplete" display="lComplete"/><memberdata name="nworkernum" display="nWorkerNum"/><memberdata name="createthread" display="CreateThread"/><memberdata name="cmtscript" display="cMTScript"/><memberdata name="lmtdll" display="lMTDLL"/><memberdata name="nmteventhandle" display="nMTEventHandle"/><memberdata name="nmthandle" display="nMTHandle"/><memberdata name="nmtthreadid" display="nMTThreadID"/><memberdata name="omtcommand" display="oMTCommand"/></VFPData>
cmtscript = 
lbusy = .F.
lcomplete = .F.
ldebugmode = .F.
llocked = .F.
lmtdll = .F.
nmteventhandle = 0
nmthandle = 0
nmtthreadid = 0
nworkernum = 0
oapplication = .NULL.
oevents = .NULL.
omtcommand = .NULL.
oworker = .NULL.
[END PROPERTIES]
[START PROTECTED]
ldebugmode
lmtdll
nmthandle
nmtthreadid
oapplication
oworker
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
Local lnThreadExitCode, lnThreadCheck
Debugout Time(0), "(" + Transform(This.nWorkerNum) + ")", Program()

#DEFINE STILL_ALIVE 259

If This.lMTDLL
	
	DECLARE INTEGER GetExitCodeThread IN kernel32;
	    INTEGER hThread,;
	    LONG @lpExitCode

    This.StopWorker()
	
	* If thread is still alive, give it a chance to stop normally before terminating
	For lnThreadCheck = 1 to 10
		lnThreadExitCode = 0
		GetExitCodeThread(This.nMTHandle, @lnThreadExitCode)
		If lnThreadExitCode <> STILL_ALIVE
			? "Thread exited normally", This.nMTHandle, lnThreadCheck
			Exit
		EndIf 
		
		? "Thread still alive", This.nMTHandle, lnThreadCheck

		* Give DMULT a chance to unload worker normally
		Inkey(.1, "H")
	EndFor 
		
	* Kill thread if it is still running
	* Heavy handed, but otherwise VFP will crash, especially after CLEAR ALL
	If lnThreadExitCode = STILL_ALIVE
		Declare Long TerminateThread IN kernel32 ;
			Long hThread, Long dwExitCode
			
	 	? "TerminateThread:", This.nMTHandle, TerminateThread(This.nMTHandle, 0)
	EndIf 

	Declare CloseHandle in Win32API LONG
		
	CloseHandle(This.nMTEventHandle)
	CloseHandle(This.nMTHandle)

EndIf 


ENDPROC
PROCEDURE Init
* Create worker process
Lparameters lcProcedureFile, lcDirectory, llDebugMode, lnWorkerNum, llMTDLL
Local lhWndForeground
Local loVFP as VisualFoxPro.Application, lcWorkerVCX, lcWorkerAPP, lcWorkerCmd

Debugout Time(0), "(" + Transform(lnWorkerNum) + ")", Program(), lcProcedureFile, lcDirectory, llDebugMode, llMTDLL

This.lMTDLL = llMTDLL

* In Windows XP and earlier, main process can lose focus when 
*	instantiating COM EXE. Make sure we keep it.
DECLARE INTEGER GetForegroundWindow IN user32
lhWndForeground = GetForegroundWindow()

This.nWorkerNum = lnWorkerNum
* Debug mode starts workers in full VFP.
If llDebugMode and _VFP.StartMode = 0
	loVFP = CreateObject("VisualFoxPro.Application." + SUBSTR(VERSION(4),2,1))
	loVFP.Visible = .t.
	This.lDebugMode = .t.
	This.lMTDLL = .f.
Else 
	* Must maintain reference to Application object, or COM instance will close even though we also 
	*	have reference to Worker object.
	If !This.lMTDLL
		This.oApplication = CreateObject("ParallelFox.Application")
		loVFP = This.oApplication.VFP
	EndIf 
 	lcWorkerVCX = FullPath(_Screen.ParPoolMgr.cWorkerLibrary)
*JAL*		This.oWorker = CreateObject(_Screen.ParPoolMgr.cWorkerCOMProgID)
EndIf 
* ParallelFox.vcx is compiled into APP/EXE
If InList(Upper(JustExt(lcProcedureFile)), "APP", "EXE")
	lcWorkerApp = FullPath(lcProcedureFile)
Else 
	lcWorkerApp = ""
EndIf 

* Set up worker events
This.oEvents = NewObject("Events", "ParallelFox.vcx")
This.oEvents.Name = "WorkerProxyEvents"	&& to distinguish object from other events objects during debugging
BindEvent(This.oEvents, "Complete", This, "Complete", 1)
BindEvent(This.oEvents, "ReturnError", This, "HandleError", 1)

lcDirectory = ["] + Evl(lcDirectory, FullPath("")) + ["]
lcProcedureFile = Evl(lcProcedureFile, "")
If This.lMTDLL
	* Multi-threaded DLL
	Text to This.cMTScript TEXTMERGE NOSHOW 
		Lparameters loWorkerProxy as WorkerProxy of ParallelFox.vcx
		Local loWorkerMgr as WorkerMgr of ParallelFox.vcx, loException as Exception, lcException
		Try 
			CD <<lcDirectory>>
			StrToFile(Transform(Datetime()) + ": Creating WorkerMgr Object" + Chr(13), "MTLog.txt", 1)
			loWorkerMgr = NewObject("<<_Screen.ParPoolMgr.cWorkerClass>>", "<<lcWorkerVCX>>", "<<lcWorkerApp>>")
			StrToFile(Transform(Datetime()) + ": Setting Main Process" + Chr(13), "MTLog.txt", 1)
			StrToFile(Transform(Datetime()) + ": ThreadID " + Transform(loWorkerProxy.Application.ThreadID) + Chr(13), "MTLog.txt", 1)
			loWorkerMgr.SetMainProcess(loWorkerProxy.Application, "<<lcWorkerApp>>")
			StrToFile(Transform(Datetime()) + ": Setting Procedure File" + Chr(13), "MTLog.txt", 1)
			If !Empty("<<lcProcedureFile>>")
				Set Procedure To "<<lcProcedureFile>>" Additive
			EndIf 
		Catch to loException
			lcException = "Error: " + Transform(loException.ErrorNo) + Chr(13) ;
				+ "Message: " + Transform(loException.Message) + Chr(13) ;
				+ "Program: " + Transform(loException.Procedure) + Chr(13) ;
				+ "LineNo: " + Transform(loException.LineNo) + Chr(13) ;
				+ "Code: " + Transform(loException.LineContents) + Chr(13)
			StrToFile(lcException, "MTLog.txt", 1)
		EndTry 
		loWorkerMgr.StartMTCommandLoop(loWorkerProxy)
	EndText 
	This.CreateThread("ParallelFoxMT.Application")
Else 
	lcWorkerVCX = FullPath(_Screen.ParPoolMgr.cWorkerLibrary)
	If Directory(JustPath(lcWorkerVCX))
		loVFP.DoCmd([CD "] + JustPath(lcWorkerVCX) + ["])
	EndIf 
	lcWorkerCmd = Textmerge([NewObject("<<_Screen.ParPoolMgr.cWorkerClass>>", "<<lcWorkerVCX>>", "<<lcWorkerApp>>")])
	This.oWorker = loVFP.Eval(lcWorkerCmd)

	* In Windows XP and earlier, main process can lose focus when 
	*	instantiating COM EXE. Make sure we keep it.
	* This issue apparently only affects IDE, and can cause wrong window 
	*	to get focus at runtime if workers started when main VFP window is not visible.
	*	So, only applying to IDE.  May revisit if issue presents itself at runtime or other scenarios.
	If _VFP.StartMode = 0 and Os(3) < "6" and GetForegroundWindow() <> lhWndForeground
		DECLARE INTEGER SetForegroundWindow IN user32 INTEGER hwnd
		SetForegroundWindow(lhWndForeground)
	EndIf

	This.oWorker.SetMainProcess(_VFP, lcWorkerApp)
	This.oWorker.DoCmd("CD " + lcDirectory)
	If !Empty(lcProcedureFile)
		lcProcedureFile = ["] + lcProcedureFile + ["]
		This.oWorker.DoCmd("Set Procedure To " + lcProcedureFile + " Additive")
	EndIf 
	This.oWorker.SetWorkerEvents(This.oEvents)
EndIf 

ENDPROC
PROCEDURE complete
Lparameters lvReturn

Debugout Time(0), "(" + Transform(This.nWorkerNum) + ")", Program(), lvReturn

* Unbind command events and rebind events to this object
UnBindEvents(This.oEvents)
BindEvent(This.oEvents, "Complete", This, "Complete", 1)
BindEvent(This.oEvents, "ReturnError", This, "HandleError", 1)

This.lComplete = .t.
*JAL*	This.lBusy = .f.
*JAL*	_Screen.ParPoolMgr.nBusyWorkers = _Screen.ParPoolMgr.nBusyWorkers - 1 
_Screen.ParPoolMgr.ProcessQueue()

ENDPROC
PROCEDURE createthread
* Create thread for MTDLL using Christof's DMULT
Lparameters lcWorkerCOMProgID
Local lnThreadID

Declare Long CreateThreadWithObject in DMult.DLL ;
	String lpszClass, ;
	String lpszMethod, ;
	Object oRef,  ;
	Long @lpdwThreadId 

* Create event 
* Win32 event is sent to MTDLL when main thread is ready to process another command
DECLARE INTEGER CreateEvent IN kernel32;
    INTEGER lpEventAttributes, INTEGER bManualReset,;
    INTEGER bInitialState, STRING lpName
 
DECLARE INTEGER SetEvent IN kernel32 INTEGER hEvent

This.nMTEventHandle = CreateEvent (0, 0, 0, 0)

* Create thread 
lnThreadID = 0
This.nMTHandle = CreateThreadWithObject( ;
	Strconv(lcWorkerCOMProgID + Chr(0),5), ;
	Strconv("StartMTWorker" + Chr(0),5), ;
	_VFP.Eval("This"), ;
	@lnThreadID)

This.nMTThreadID = lnThreadID

? "Event Handle", This.nMTEventHandle
? "Thread Handle", This.nMTHandle
? "Thread ID", This.nMTThreadID


ENDPROC
PROCEDURE handleerror
Lparameters lnError, lcMethod, lnLine, lcMessage, lcCode

Debugout Time(0), "(" + Transform(This.nWorkerNum) + ")", Program(), lnError, lcMethod, lnLine, lcMessage, lcCode

This.Complete()
ENDPROC
PROCEDURE sendcommand
* Send command to worker process.
Lparameters loCommand as Command of ParallelFox.vcx

Debugout Time(0), "(" + Transform(This.nWorkerNum) + ")", Program(), loCommand.cCommandType, loCommand.cCommand, ;
	loCommand.cClass, loCommand.cModule

* Make sure events objects are in same data session
This.oEvents.SetDataSession(loCommand.oEvents.GetDataSession())

* Bind events to current event object
BindEvent(This.oEvents, "Complete", loCommand.oEvents, "Complete")
BindEvent(This.oEvents, "ReturnError", loCommand.oEvents, "ReturnError")
BindEvent(This.oEvents, "ReturnData", loCommand.oEvents, "ReturnData")
BindEvent(This.oEvents, "UpdateProgress", loCommand.oEvents, "UpdateProgress")
BindEvent(This.oEvents, "ReturnCursor", loCommand.oEvents, "ReturnCursor")

If This.lMTDLL
	* Set command, then send event so MTDLL worker will grab command from main process
	This.oMTCommand = loCommand
	SetEvent(This.nMTEventHandle)
Else 
	This.oWorker.SendCommand(loCommand)
EndIf 

ENDPROC
PROCEDURE stopworker
Debugout Time(0), "(" + Transform(This.nWorkerNum) + ")", Program()

This.oWorker = NULL
This.oApplication = NULL

If This.lMTDLL

*JAL*		Declare Long CreateThreadWithObject in DMult.DLL ;
*JAL*			String lpszClass, ;
*JAL*			String lpszMethod, ;
*JAL*			Object oRef,  ;
*JAL*			Long @lpdwThreadId 

? Program()

	This.cMTScript = "STOPWORKER"
	SetEvent(This.nMTEventHandle)
EndIf 

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*complete Fires when worker has finished executing command.
*createthread Create thread for MTDLL.
*handleerror Fires when error returned from worker.
*sendcommand Send command to worker process.
*stopworker Stop worker process.
_memberdata XML Metadata for customizable properties
cmtscript Startup/Stop script for MTDLL worker.
lbusy Worker is busy processing command.
lcomplete Is .T. when current command is complete, but lBusy is still .T. Worker will be released for another command when queue is processed.
ldebugmode Start workers in Debug mode.
llocked Is .T. when worker is locked to a specific command and was busy when command queue was processed.
lmtdll Is .T. when using MTDLL workers.
nmteventhandle Handle for Win32 events sent to MTDLL to process a command.
nmthandle Thread Handle
nmtthreadid Thread ID
nworkernum Worker number.
oapplication Reference to ParallelFox Application COM object.
oevents Reference to worker events object.
omtcommand Command object for MTDLL worker.
oworker Reference to Worker process.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] workerproxy
[EOF]
