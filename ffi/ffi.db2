*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="ffi.dbf" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*


<TABLE>
	<MemoFile></MemoFile>
	<CodePage>1252</CodePage>
	<LastUpdate></LastUpdate>
	<Database></Database>
	<FileType>0x00000030</FileType>
	<FileType_Descrip>Visual FoxPro</FileType_Descrip>

	<FIELDS>
		<FIELD>
			<Name>MEMBER</Name>
			<Type>C</Type>
			<Width>200</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.F.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
		<FIELD>
			<Name>TYPE</Name>
			<Type>C</Type>
			<Width>1</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.F.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
		<FIELD>
			<Name>DESCRIP</Name>
			<Type>M</Type>
			<Width>4</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.F.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
		<FIELD>
			<Name>TIP</Name>
			<Type>M</Type>
			<Width>4</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.F.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
		<FIELD>
			<Name>SCRIPT</Name>
			<Type>M</Type>
			<Width>4</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.F.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
		<FIELD>
			<Name>CLASS</Name>
			<Type>C</Type>
			<Width>60</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.F.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
		<FIELD>
			<Name>LIBRARY</Name>
			<Type>M</Type>
			<Width>4</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.F.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
	</FIELDS>


	<indexFile>FFI.CDX</indexFile>

	<INDEXES>
		<INDEX>
			<TagName>CLASS</TagName>
			<TagType>REGULAR</TagType>
			<Key>UPPER(CLASS)</Key>
			<Filter></Filter>
			<Order>ASCENDING</Order>
			<Collate>MACHINE</Collate>
		</INDEX>
		<INDEX>
			<TagName>MEMBER</TagName>
			<TagType>REGULAR</TagType>
			<Key>UPPER(MEMBER)</Key>
			<Filter></Filter>
			<Order>ASCENDING</Order>
			<Collate>MACHINE</Collate>
		</INDEX>
	</INDEXES>



	<RECORDS>

		<RECORD>
			<MEMBER>Parallel</MEMBER>
			<TYPE>C</TYPE>
			<DESCRIP><![CDATA[ParallelFox Parallel Processing Library]]></DESCRIP>
			<TIP></TIP>
			<SCRIPT></SCRIPT>
			<CLASS>Parallel</CLASS>
			<LIBRARY><![CDATA[ParallelFox.vcx]]></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.BindEvent</MEMBER>
			<TYPE>F</TYPE>
			<DESCRIP><![CDATA[Bind to worker events: "Complete", "UpdateProgress", "ReturnData", "ReturnError".]]></DESCRIP>
			<TIP><![CDATA[cEvent, oEventHandler, cDelegate, [nFlags]]]></TIP>
			<SCRIPT><![CDATA[lparameters toFoxCode, ;
  toData
local lcMember, ;
  lnPos, ;
  lcParameters, ;
  lnParameters
lcMember     = alltrim(substr(toData.Member, rat('.', toData.Member) + 1))
lnPos        = atc(lcMember, toFoxCode.FullLine)
lcParameters = substr(toFoxCode.FullLine, lnPos + len(lcMember))
lnParameters = occurs(',', lcParameters) + 1
do case
  case lnParameters = 1
    dimension toFoxCode.Items[5, 2]
    toFoxCode.Items[1, 1] = ["Complete"]
    toFoxCode.Items[1, 2] = [Bind to Worker "Complete" event.]
    toFoxCode.Items[2, 1] = ["UpdateProgress"]
    toFoxCode.Items[2, 2] = [Bind to Worker "UpdateProgress" event.]
    toFoxCode.Items[3, 1] = ["ReturnData"]
    toFoxCode.Items[3, 2] = [Bind to Worker "ReturnData" event.]
    toFoxCode.Items[4, 1] = ["ReturnError"]
    toFoxCode.Items[4, 2] = [Bind to Worker "ReturnError" event.]
    toFoxCode.Items[5, 1] = ["ReturnCursor"]
    toFoxCode.Items[5, 2] = [Bind to Worker "ReturnCursor" event.]
    if file(home() + 'FFC\Graphics\event.bmp')
    	toFoxCode.Icon =  home() + 'FFC\Graphics\event.bmp'
    endif
    toFoxCode.ValueType = 'L'
  case lnParameters = 2
    toFoxCode.ValueTip  = 'BindEvent(eEvent,  > oEventHandler <, cDelegate,  [nFlags])' ;
    	+ chr(13) + "oEventHandler: Specifies the object, which must be a valid Visual FoxPro object, handling the event."
    toFoxCode.ValueType = 'T'
  case lnParameters = 3
    toFoxCode.ValueTip  = 'BindEvent(eEvent,  oEventHandler, > cDelegate <, [nFlags])' ;
    	+ chr(13) + [cDelegate: Specifies the method, or "delegate", that handles the event for oEventHandler. The delegate method must have the same parameters as the event specified in cEvent.]
    toFoxCode.ValueType = 'T'
  case lnParameters = 4
text to toFoxCode.ValueTip  noshow
BINDEVENT() nFlags Parameter (additive):

1 - Call event before delegate
2 - Do not allow an event  to be triggered with a simple method call *
4 - Only allow user code to execute (prevent recursion of Win Msg event)

* Note: certain native events may not work with this flag set.
endtext
    toFoxCode.ValueType = 'T'
endcase
]]></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.Call</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Execute/call function on worker.]]></DESCRIP>
			<TIP><![CDATA[Call(cFunction, [lAllWorkers], [Parameter1], [Parameter2...])]]></TIP>
			<SCRIPT><![CDATA[lparameters toFoxCode, ;
  toData
local lcMember, ;
  lnPos, ;
  lcParameters, ;
  lnParameters
lcMember     = alltrim(substr(toData.Member, rat('.', toData.Member) + 1))
lnPos        = atc(lcMember, toFoxCode.FullLine)
lcParameters = substr(toFoxCode.FullLine, lnPos + len(lcMember))
lnParameters = occurs(',', lcParameters) + 1
do case
  case lnParameters = 1
    toFoxCode.ValueTip  = 'Call(> cFunction <, [lAllWorkers], [Parameter1], [Parameter2...])' ;
    	+ chr(13) + "cFunction: Name of function to call on worker."
    toFoxCode.ValueType = 'T'
  case lnParameters = 2
    toFoxCode.ValueTip  = 'Call(cFunction, > [lAllWorkers] <, [Parameter1], [Parameter2...])' ;
    	+ chr(13) + "lAllWorkers (optional): Pass .T. to call function on all workers."
    toFoxCode.ValueType = 'T'
  otherwise
    toFoxCode.ValueTip  = 'Call(cFunction, [lAllWorkers], > [Parameter1], [Parameter2...] <)' ;
    	+ chr(13) + [Parameters (optional): Pass up to 24 parameters to cFunction.]
    toFoxCode.ValueType = 'T'
endcase
]]></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.CallMethod</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Execute/call class method on worker.]]></DESCRIP>
			<TIP><![CDATA[CallMethod(cMethod, cClassName, cModule, [cInApplication], [lAllWorkers], [Parameter1], [Parameter2...])]]></TIP>
			<SCRIPT><![CDATA[lparameters toFoxCode, ;
  toData
local lcMember, ;
  lnPos, ;
  lcParameters, ;
  lnParameters
lcMember     = alltrim(substr(toData.Member, rat('.', toData.Member) + 1))
lnPos        = atc(lcMember, toFoxCode.FullLine)
lcParameters = substr(toFoxCode.FullLine, lnPos + len(lcMember))
lnParameters = occurs(',', lcParameters) + 1
do case
  case lnParameters = 1
    toFoxCode.ValueTip  = 'CallMethod(> cMethod <, cClassName, cModule, [cInApplication], [lAllWorkers], [Parameter1], [Parameter2...])' ;
    	+ chr(13) + "cMethod: Name of method to call on worker."
    toFoxCode.ValueType = 'T'
  case lnParameters = 2
    toFoxCode.ValueTip  = 'CallMethod(cMethod, > cClassName <, cModule, [cInApplication], [lAllWorkers], [Parameter1], [Parameter2...])' ;
    	+ chr(13) + "cClassName: Name of class containing method specified with cMethod."
    toFoxCode.ValueType = 'T'
  case lnParameters = 3
    toFoxCode.ValueTip  = 'CallMethod(cMethod, cClassName, > cModule <, [cInApplication], [lAllWorkers], [Parameter1], [Parameter2...])' ;
    	+ chr(13) + "cModule: Name of .VCX or .PRG containing class specified with cClassName."
    toFoxCode.ValueType = 'T'
  case lnParameters = 4
    toFoxCode.ValueTip  = 'CallMethod(cMethod, cClassName, cModule, > [cInApplication] <, [lAllWorkers], [Parameter1], [Parameter2...])' ;
    	+ chr(13) + "cInApplication(optional for .PRG): Name of .EXE or .APP containing class library specified with cModule." ;
    	+ chr(13) + "NOTE: This parameter is required if cModule is a .VCX compiled into the main APP/EXE. Otherwise, ParallelFox will not be able to find the class."
    toFoxCode.ValueType = 'T'
  case lnParameters = 5
    toFoxCode.ValueTip  = 'CallMethod(cMethod, cClassName, cModule, [cInApplication], >[lAllWorkers]<, [Parameter1], [Parameter2...])' ;
    	+ chr(13) + "lAllWorkers (optional): Pass .T. to call method on all workers."
    toFoxCode.ValueType = 'T'
  otherwise
    toFoxCode.ValueTip  = 'CallMethod(cMethod, cClassName, cModule, [cInApplication], [lAllWorkers], >[Parameter1], [Parameter2...] <)' ;
    	+ chr(13) + [Parameters (optional): Pass up to 21 parameters to cMethod.]
    toFoxCode.ValueType = 'T'
endcase
]]></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.ClearQueue</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Remove all pending commands from queue.]]></DESCRIP>
			<TIP><![CDATA[ClearQueue()]]></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.CPUCount</MEMBER>
			<TYPE>P</TYPE>
			<DESCRIP><![CDATA[Number of logical processors on machine.
CPUCount is a property, not a method.]]></DESCRIP>
			<TIP></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.Do</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Execute program on worker.]]></DESCRIP>
			<TIP><![CDATA[Do(cPRG, [cInProgram], [lAllWorkers], [Parameter1], [Parameter2...])]]></TIP>
			<SCRIPT><![CDATA[lparameters toFoxCode, ;
  toData
local lcMember, ;
  lnPos, ;
  lcParameters, ;
  lnParameters
lcMember     = alltrim(substr(toData.Member, rat('.', toData.Member) + 1))
lnPos        = atc(lcMember, toFoxCode.FullLine)
lcParameters = substr(toFoxCode.FullLine, lnPos + len(lcMember))
lnParameters = occurs(',', lcParameters) + 1
do case
  case lnParameters = 1
    toFoxCode.ValueTip  = 'Do(> cPRG <, [cInProgram], [lAllWorkers], [Parameter1], [Parameter2...])' ;
    	+ chr(13) + "cPRG: Name of program or procedure to execute on worker."
    toFoxCode.ValueType = 'T'
  case lnParameters = 2
    toFoxCode.ValueTip  = 'Do(cPRG, > [cInProgram] <, [lAllWorkers], [Parameter1], [Parameter2...])' ;
    	+ chr(13) + "cInProgram (optional): Executes a procedure in the specified program file." ;
    	+ chr(13) + "Equivalent of DO MyProcedure IN MyProgramFile.prg"
    toFoxCode.ValueType = 'T'
  case lnParameters = 3
    toFoxCode.ValueTip  = 'Do(cPRG, [cInProgram], > [lAllWorkers] <, [Parameter1], [Parameter2...])' ;
    	+ chr(13) + "lAllWorkers (optional): Pass .T. to execute program on all workers."
    toFoxCode.ValueType = 'T'
  otherwise
    toFoxCode.ValueTip  = 'Do(cPRG, [cInProgram], [lAllWorkers], > [Parameter1], [Parameter2...] <)' ;
    	+ chr(13) + [Parameters (optional): Pass up to 23 parameters to cPRG.]
    toFoxCode.ValueType = 'T'
endcase
]]></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.DoCmd</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Execute single command on worker.]]></DESCRIP>
			<TIP><![CDATA[DoCmd(cCommand, lAllWorkers)]]></TIP>
			<SCRIPT><![CDATA[lparameters toFoxCode, ;
  toData
local lcMember, ;
  lnPos, ;
  lcParameters, ;
  lnParameters
lcMember     = alltrim(substr(toData.Member, rat('.', toData.Member) + 1))
lnPos        = atc(lcMember, toFoxCode.FullLine)
lcParameters = substr(toFoxCode.FullLine, lnPos + len(lcMember))
lnParameters = occurs(',', lcParameters) + 1
do case
  case lnParameters = 1
    toFoxCode.ValueTip  = 'DoCmd(> cCommand <, [lAllWorkers],)' ;
    	+ chr(13) + "cCommand: Execute command on worker." ;
    	+ chr(13) + "Equivalent of _VFP.DoCmd()"
    toFoxCode.ValueType = 'T'
  case lnParameters = 2
    toFoxCode.ValueTip  = 'DoCmd(cCommand, > [lAllWorkers] <,)' ;
    	+ chr(13) + "lAllWorkers (optional): Pass .T. to execute command on all workers."
    toFoxCode.ValueType = 'T'
endcase
]]></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.ExecScript</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Execute script on worker.]]></DESCRIP>
			<TIP><![CDATA[ExecScript(cScript, [lAllWorkers], [Parameter1], [Parameter2...]]]></TIP>
			<SCRIPT><![CDATA[lparameters toFoxCode, ;
  toData
local lcMember, ;
  lnPos, ;
  lcParameters, ;
  lnParameters
lcMember     = alltrim(substr(toData.Member, rat('.', toData.Member) + 1))
lnPos        = atc(lcMember, toFoxCode.FullLine)
lcParameters = substr(toFoxCode.FullLine, lnPos + len(lcMember))
lnParameters = occurs(',', lcParameters) + 1
do case
  case lnParameters = 1
    toFoxCode.ValueTip  = 'ExecScript(> cScript <, [lAllWorkers], [Parameter1], [Parameter2...])' ;
    	+ chr(13) + "cScript: Script to execute on worker."
    toFoxCode.ValueType = 'T'
  case lnParameters = 2
    toFoxCode.ValueTip  = 'ExecScript(cScript, > [lAllWorkers] <, [Parameter1], [Parameter2...])' ;
    	+ chr(13) + "lAllWorkers (optional): Pass .T. to execute script on all workers."
    toFoxCode.ValueType = 'T'
  otherwise
    toFoxCode.ValueTip  = 'ExecScript(cScript, [lAllWorkers], > [Parameter1], [Parameter2...] <)' ;
    	+ chr(13) + [Parameters (optional): Pass up to 24 parameters to cScript.]
    toFoxCode.ValueType = 'T'
endcase
]]></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.OnError</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Set up global handler for worker errors.]]></DESCRIP>
			<TIP><![CDATA[OnError(> cOnErrorCommand <)
cOnErrorCommand: Global error handler command.
Available variables are nError, cMethod, nLine, cMessage, cCode.
Example: Parallel.OnError("Do MyErrorHandler with nError, cMethod, nLine, cMessage, cCode")]]></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.SetWorkerClass</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Change worker class from default if you override WorkerMgr class.
Must be called before StartWorkers() method.]]></DESCRIP>
			<TIP><![CDATA[SetWorkerClass(cCOMProgID, cClass, cLibrary)]]></TIP>
			<SCRIPT><![CDATA[lparameters toFoxCode, ;
  toData
local lcMember, ;
  lnPos, ;
  lcParameters, ;
  lnParameters
lcMember     = alltrim(substr(toData.Member, rat('.', toData.Member) + 1))
lnPos        = atc(lcMember, toFoxCode.FullLine)
lcParameters = substr(toFoxCode.FullLine, lnPos + len(lcMember))
lnParameters = occurs(',', lcParameters) + 1
do case
  case lnParameters = 1
    toFoxCode.ValueTip  = "SetWorkerClass(> cCOMProgID <, cClass, cLibrary)" ;
    	+ chr(13) + "cCOMProgID: COM ProgID for worker class." ;
    	+ chr(13) + "Default is ParallelFox.WorkerMgr."
    toFoxCode.ValueType = 'T'
  case lnParameters = 2
    toFoxCode.ValueTip  = "SetWorkerClass(cCOMProgID, > cClass <, cLibrary)" ;
    	+ chr(13) + "cClass: Worker class to instantiate in Debug Mode."
    toFoxCode.ValueType = 'T'
  case lnParameters = 3
    toFoxCode.ValueTip  = "SetWorkerClass(cCOMProgID, cClass, > cLibrary <)" ;
    	+ chr(13) + "cLibrary: Class library containing cClass for Debug Mode." ;
    	+ chr(13) + "Must be accessible in main process path."
    toFoxCode.ValueType = 'T'
endcase
]]></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.SetWorkerCount</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Set number of workers.
Defaults to CPU count.
Set before starting workers.]]></DESCRIP>
			<TIP><![CDATA[SetWorkerCount(nWorkerCount, nTerminalServerCount)]]></TIP>
			<SCRIPT><![CDATA[lparameters toFoxCode, ;
  toData
local lcMember, ;
  lnPos, ;
  lcParameters, ;
  lnParameters
lcMember     = alltrim(substr(toData.Member, rat('.', toData.Member) + 1))
lnPos        = atc(lcMember, toFoxCode.FullLine)
lcParameters = substr(toFoxCode.FullLine, lnPos + len(lcMember))
lnParameters = occurs(',', lcParameters) + 1
do case
  case lnParameters = 1
    toFoxCode.ValueTip  = 'SetWorkerCount(> nWorkerCount <, [nTerminalServerCount])' ;
    	+ chr(13) + "nWorkerCount: Number of worker processes to start." ;
    	+ chr(13) + "Defaults to Parallel.CPUCount."
    toFoxCode.ValueType = 'T'
  case lnParameters = 2
    toFoxCode.ValueTip  = 'SetWorkerCount(nWorkerCount, > [nTerminalServerCount] <)' ;
    	+ chr(13) + "nTerminalServerCount (optional): Number of worker processes to start on Terminal Server." ;
    	+ chr(13) + "Default is 1."
    toFoxCode.ValueType = 'T'
endcase
]]></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.StartWorkers</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Start worker processes.]]></DESCRIP>
			<TIP><![CDATA[StartWorkers(cProcedureFile, [cDirectory], [lDebugMode])]]></TIP>
			<SCRIPT><![CDATA[lparameters toFoxCode, ;
  toData
local lcMember, ;
  lnPos, ;
  lcParameters, ;
  lnParameters
lcMember     = alltrim(substr(toData.Member, rat('.', toData.Member) + 1))
lnPos        = atc(lcMember, toFoxCode.FullLine)
lcParameters = substr(toFoxCode.FullLine, lnPos + len(lcMember))
lnParameters = occurs(',', lcParameters) + 1
do case
  case lnParameters = 1
    toFoxCode.ValueTip  = "StartWorkers(> cProcedureFile <, [cDirectory], [lDebugMode])" ;
    	+ chr(13) + "cProcedureFile: The EXE, APP, or procedure file containing code to run on workers."
    toFoxCode.ValueType = 'T'
  case lnParameters = 2
    toFoxCode.ValueTip  = "StartWorkers(cProcedureFile, > [cDirectory] <, [lDebugMode])" ;
    	+ chr(13) + "cDirectory (optional): Directory to start worker in." ;
    	+ chr(13) + "Defaults to current directory in main process."
    toFoxCode.ValueType = 'T'
  case lnParameters = 3
    toFoxCode.ValueTip  = "StartWorkers(cProcedureFile, [cDirectory], > [lDebugMode] <)" ;
    	+ chr(13) + "lDebugMode (optional): Pass .T. to start workers in separate, visible instances of Visual FoxPro for debugging."
    toFoxCode.ValueType = 'T'
endcase
]]></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.Wait</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Wait until workers have finished processing queued commands.]]></DESCRIP>
			<TIP><![CDATA[Wait(> [lAllWorkers] <)
lAllWorkers (optional): Pass .T. to wait for commands from ALL instances of Parallel object.
When .F. or omitted, wait only for commands from current instance of Parallel object.]]></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.StopWorkers</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Stop worker processes.]]></DESCRIP>
			<TIP><![CDATA[StopWorkers(> [lStopImmediately] <)
lStopImmediately (optional): Pass .T. to stop workers immediately.
By default, wait until all queued commands complete before stopping workers.]]></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Worker</MEMBER>
			<TYPE>C</TYPE>
			<DESCRIP><![CDATA[ParallelFox Worker]]></DESCRIP>
			<TIP></TIP>
			<SCRIPT></SCRIPT>
			<CLASS>Worker</CLASS>
			<LIBRARY><![CDATA[ParallelFox.vcx]]></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Worker.CPUCount</MEMBER>
			<TYPE>P</TYPE>
			<DESCRIP><![CDATA[Number of logical processors on machine.
CPUCount is a property, not a method.]]></DESCRIP>
			<TIP></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Worker.EndCriticalSection</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[End Critical Section of code.]]></DESCRIP>
			<TIP><![CDATA[EndCriticalSection(> cCriticalSectionName <)
cCriticalSectionName: Name of critical section to end.]]></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Worker.IsWorker</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Returns .T. if currently running in Worker process.]]></DESCRIP>
			<TIP></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Worker.ProgressInterval</MEMBER>
			<TYPE>P</TYPE>
			<DESCRIP><![CDATA[Minimum number of seconds between progress updates when calling UpdateProgress().
Default is 1 second.
ProgressInterval is a property, not a method.]]></DESCRIP>
			<TIP></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Worker.ReturnCursor</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Return cursor to main process.]]></DESCRIP>
			<TIP><![CDATA[ReturnCursor(> [cAlias] <)
cAlias (optional): Alias of cursor to return to main process.]]></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Worker.ReturnData</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Return data to main process.
Due to limitations with VFP BindEvent(), arrays are not supported and cannot be returned.]]></DESCRIP>
			<TIP><![CDATA[ReturnData(Parameter1, [Parameter2...])
Return up to 26 parameters to main process.]]></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Worker.ReturnError</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Return error to main process.]]></DESCRIP>
			<TIP><![CDATA[ReturnError(nError, cMethod, nLine, cMessage, cCode)]]></TIP>
			<SCRIPT><![CDATA[lparameters toFoxCode, ;
  toData
local lcMember, ;
  lnPos, ;
  lcParameters, ;
  lnParameters
lcMember     = alltrim(substr(toData.Member, rat('.', toData.Member) + 1))
lnPos        = atc(lcMember, toFoxCode.FullLine)
lcParameters = substr(toFoxCode.FullLine, lnPos + len(lcMember))
lnParameters = occurs(',', lcParameters) + 1
do case
  case lnParameters = 1
    toFoxCode.ValueTip  = 'ReturnError(> nError <, cMethod, nLine, cMessage, cCode)' ;
    	+ chr(13) + "nError: Error number."
    toFoxCode.ValueType = 'T'
  case lnParameters = 2
    toFoxCode.ValueTip  = 'ReturnError(nError, > cMethod <, nLine, cMessage, cCode)' ;
    	+ chr(13) + "cMethod: Method/program containing error."
    toFoxCode.ValueType = 'T'
  case lnParameters = 3
    toFoxCode.ValueTip  = 'ReturnError(nError, cMethod, > nLine <, cMessage, cCode)' ;
    	+ chr(13) + "nLine: Line number containing error."
    toFoxCode.ValueType = 'T'
  case lnParameters = 4
    toFoxCode.ValueTip  = 'ReturnError(nError, cMethod, nLine, > cMessage <, cCode)' ;
    	+ chr(13) + "cMessage: Error message."
    toFoxCode.ValueType = 'T'
  case lnParameters = 5
    toFoxCode.ValueTip  = 'ReturnError(nError, cMethod, nLine, cMessage, > cCode <)' ;
    	+ chr(13) + "cCode: Line of code that caused the error."
    toFoxCode.ValueType = 'T'
endcase
]]></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Worker.Sleep</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Pause execution on worker.]]></DESCRIP>
			<TIP><![CDATA[Sleep(nMilliseconds, [nCPUCount])]]></TIP>
			<SCRIPT><![CDATA[lparameters toFoxCode, ;
  toData
local lcMember, ;
  lnPos, ;
  lcParameters, ;
  lnParameters
lcMember     = alltrim(substr(toData.Member, rat('.', toData.Member) + 1))
lnPos        = atc(lcMember, toFoxCode.FullLine)
lcParameters = substr(toFoxCode.FullLine, lnPos + len(lcMember))
lnParameters = occurs(',', lcParameters) + 1
do case
  case lnParameters = 1
    toFoxCode.ValueTip  = 'Sleep(> nMilliseconds <, [nCPUCount])' ;
    	+ chr(13) + "nMilliseconds: Number of milliseconds to pause execution." ;
    	+ chr(13) + "Pass 0 to force process/thread switch without delay."
    toFoxCode.ValueType = 'T'
  case lnParameters = 2
    toFoxCode.ValueTip  = 'Sleep(nMilliseconds, > [nCPUCount] <)' ;
    	+ chr(13) + "nCPUCount (optional): Pause only if machine contains the specified number CPUs or fewer." ;
    	+ chr(13) + "Omit (or pass 0) to pause regardless of CPUs."
    toFoxCode.ValueType = 'T'
endcase
]]></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Worker.StartCriticalSection</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Start Critical Section of code.]]></DESCRIP>
			<TIP><![CDATA[StartCriticalSection(> cCriticalSectionName <)
cCriticalSectionName: Name of critical section.
Specify a unique (but not random) name for each critical section.]]></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Worker.UpdateProgress</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Send progress update to main process.]]></DESCRIP>
			<TIP><![CDATA[UpdateProgress(nProgress, cMessage, lForceUpdate)]]></TIP>
			<SCRIPT><![CDATA[lparameters toFoxCode, ;
  toData
local lcMember, ;
  lnPos, ;
  lcParameters, ;
  lnParameters
lcMember     = alltrim(substr(toData.Member, rat('.', toData.Member) + 1))
lnPos        = atc(lcMember, toFoxCode.FullLine)
lcParameters = substr(toFoxCode.FullLine, lnPos + len(lcMember))
lnParameters = occurs(',', lcParameters) + 1
do case
  case lnParameters = 1
    toFoxCode.ValueTip  = 'UpdateProgress(> nProgress <, cMessage, [lForceUpdate])' ;
    	+ chr(13) + "nProgress: Progress number/percentage complete."
    toFoxCode.ValueType = 'T'
  case lnParameters = 2
    toFoxCode.ValueTip  = 'UpdateProgress(nProgress, > cMessage <, [lForceUpdate])' ;
    	+ chr(13) + "cMessage: Progress message."
    toFoxCode.ValueType = 'T'
  case lnParameters = 3
    toFoxCode.ValueTip  = 'UpdateProgress(nProgress, cMessage, > [lForceUpdate] <)' ;
    	+ chr(13) + "lForceUpdate (optional): Pass .T. to force immediate update and disregard Worker.ProgressInterval."
    toFoxCode.ValueType = 'T'
endcase
]]></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.DetectHyperThreading</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Returns .T. when HyperThreading is enabled.
Functional on Windows XP SP3, Windows Server 2003, and later only.]]></DESCRIP>
			<TIP><![CDATA[DetectHyperThreading()
Functional on Windows XP SP3, Windows Server 2003, and later only.]]></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.SetMultiThreaded</MEMBER>
			<TYPE>F</TYPE>
			<DESCRIP><![CDATA[Set to use in-process multithreaded DLL workers or out-of-process EXEs.
Must be set before StartWorkers is called.]]></DESCRIP>
			<TIP><![CDATA[SetMultiThreaded(\b lMTDLL \b0)
Set .T. to use in-process multithreaded DLL workers. Otherwise, out-of-process EXEs are used.]]></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

		<RECORD>
			<MEMBER>Parallel.SetInstance</MEMBER>
			<TYPE>M</TYPE>
			<DESCRIP><![CDATA[Set/switch to instance of parallel pool manager, creating new instance if necessary.
Call before StartWorkers() and other Set... functions.]]></DESCRIP>
			<TIP><![CDATA[SetInstance(> [cInstanceName] <)
Name of instance to set/switch to.
Default instance name is "DEFAULT"., Two]]></TIP>
			<SCRIPT></SCRIPT>
			<CLASS></CLASS>
			<LIBRARY></LIBRARY>
		</RECORD>

	</RECORDS>


</TABLE>

