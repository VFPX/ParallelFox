*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="parallelfox.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS amanager AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: copyarray		&& Copy array.
		*m: createparameterclause		&& Create parameter clause from parameter object.
		*m: createparameterobject
		*m: detecthyperthreading		&& Detect if HyperThreading is turned on.
		*p: lhyperthreading		&& Is .T. when HyperThreading is turned on.
		*a: aarraycopy[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	lhyperthreading = .NULL.		&& Is .T. when HyperThreading is turned on.
	Name = "amanager"
	_memberdata = <VFPData>
		<memberdata name="createparameterobject" display="CreateParameterObject"/>
		<memberdata name="createparameterclause" display="CreateParameterClause"/>
		<memberdata name="aarraycopy" display="aArrayCopy"/>
		<memberdata name="copyarray" display="CopyArray"/>
		<memberdata name="detecthyperthreading" display="DetectHyperThreading"/>
		<memberdata name="lhyperthreading" display="lHyperThreading"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE copyarray		&& Copy array.
		* Copy array to worker.
		* ACOPY doesn't work when run from worker on array that is COM object property.
		* Must pass array as parameter to worker.
		Lparameters laArray
		
		Debugout Time(0), Program()
		
		Acopy(laArray, This.aArrayCopy)
		
	ENDPROC

	PROCEDURE createparameterclause		&& Create parameter clause from parameter object.
		* Convert parameter object into variables
		* Pass in parameter variables by reference ("out" variables)
		Lparameters loParameters, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24, tPar25
		Local lnPCount, lnParameter, lcParameter, lcParameterClause
		
		Debugout Time(0), Program()
		
		* Convert array to parameters and parameter clause
		lcParameterClause = ""
		lnPCount = loParameters.nPCount
		For lnParameter = 1 to lnPCount
			lcParameter = "tPar" + Transform(lnParameter)
			
			* Build parameter clause
			If !Empty(lcParameterClause)
				lcParameterClause = lcParameterClause + ", "
			EndIf 
			If loParameters.IsArray(lcParameter)
				* Arrays have to be copied from object property and passed by reference
				loParameters.CopyArray(lcParameter, This)
				Dimension &lcParameter.[1]
				Acopy(This.aArrayCopy, &lcParameter)
				lcParameterClause = lcParameterClause + "@" + lcParameter
			Else
				&lcParameter = loParameters.&lcParameter
				lcParameterClause = lcParameterClause + lcParameter
			EndIf 
		EndFor 
		
		Return lcParameterClause
		
		
	ENDPROC

	PROCEDURE createparameterobject
		* Convert parameters into parameter object
		* Pass in all parameters by reference in case any are arrays.
		Lparameters lnPCount, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24, tPar25
		Local lnParameter, lcParameter, loParameters as Parameters of ParallelFox.vcx, lvValue
		
		Debugout Time(0), Program()
		
		loParameters = NewObject("Parameters","ParallelFox.vcx")
		loParameters.nPCount = lnPCount
		* AddProperty(loParameters, "nPCount", lnPCount)
		
		* Create array of serialized parameters 
		For lnParameter = 1 to lnPCount
			lcParameter = "tPar" + Transform(lnParameter)
			If Type(lcParameter, 1) = "A"
				* Arrays have to be copied to object property
				AddProperty(loParameters, lcParameter + "[1]")
				Acopy(&lcParameter, loParameters.&lcParameter)
			Else 
				AddProperty(loParameters, lcParameter)
				loParameters.&lcParameter = Evaluate(lcParameter)
			EndIf 
		EndFor 
			
		Return loParameters
	ENDPROC

	PROCEDURE detecthyperthreading		&& Detect if HyperThreading is turned on.
		* Use WMI to determine if HyperThreading is turned on
		* This only works on Windows XP SP3, Windows Server 2003, and later because
		*	underlying Windows APIs were not added until those versions.
		Local lcWMIFolder, loWMI, lcolProcessors, loProcessor
		
		This.lHyperThreading = .F.
		
		lcWMIFolder = Addbs(GetEnv("SystemRoot")) + "System32\WBEM\"
		If Directory(lcWMIFolder)	&& make sure installed
			loWMI = GetObject("winmgmts:\\.\root\cimv2")
			lcolProcessors = loWMI.ExecQuery("Select * from Win32_Processor")
			For each loProcessor in lcolProcessors FoxObject
				If Type("loProcessor.NumberOfCores")<> "U" and Type("loProcessor.NumberOfLogicalProcessors")<> "U"
					* If logical processors > actual cores, HT must be turned on
					If loProcessor.NumberOfLogicalProcessors > loProcessor.NumberOfCores
						This.lHyperThreading = .T.
					EndIf 
				EndIf 
			EndFor 
		EndIf 
	ENDPROC

ENDDEFINE

DEFINE CLASS command AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cclass		&& Class containing command (if applicable).
		*p: ccommand		&& Command.
		*p: ccommandtype		&& Command type.
		*p: cinapplication		&& Application containing class library.
		*p: cmodule		&& Module/Class Library containing command (if applicable).
		*p: nworker		&& Specifies which worker to run on.  0 means next available. Used to run a command on all workers.
		*p: oevents		&& Events object.
		*p: oparameters		&& Parameter object.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	cclass = 		&& Class containing command (if applicable).
	ccommand = 		&& Command.
	ccommandtype = 		&& Command type.
	cinapplication = 		&& Application containing class library.
	cmodule = 		&& Module/Class Library containing command (if applicable).
	Name = "command"
	nworker = 0		&& Specifies which worker to run on.  0 means next available. Used to run a command on all workers.
	oevents = .NULL.		&& Events object.
	oparameters = .NULL.		&& Parameter object.
	_memberdata = <VFPData>
		<memberdata name="ccommandtype" display="cCommandType"/>
		<memberdata name="ccommand" display="cCommand"/>
		<memberdata name="cclass" display="cClass"/>
		<memberdata name="cmodule" display="cModule"/>
		<memberdata name="oparameters" display="oParameters"/>
		<memberdata name="nworker" display="nWorker"/>
		<memberdata name="oevents" display="oEvents"/>
		<memberdata name="cinapplication" display="cInApplication"/>
		</VFPData>		&& XML Metadata for customizable properties

ENDDEFINE

DEFINE CLASS errorhandler AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: handleerror		&& Handle worker error.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Name = "errorhandler"
	_memberdata = <VFPData>
		<memberdata name="handleerror" display="HandleError"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE handleerror		&& Handle worker error.
		* Handle worker error and return to main process
		Lparameters lnError, lcMethod, lnLine, lcMessage, lcCode
		Local Worker as Worker
		Worker = NewObject("Worker", "ParallelFox.vcx")
		
		Worker.ReturnError(lnError, lcMethod, lnLine, lcMessage, lcCode)
		
		* Exit current code containing error and return to command processor
		Return to ProcessCommand 
	ENDPROC

	PROCEDURE Init
		* Default error handler 
		* Unhandled errors may cause workers to crash when not in debug mode
		
		On Error _Screen.oErrorHandler.HandleError(Error(), Sys(16), Lineno(1), Message(), Message(1))
	ENDPROC

ENDDEFINE

DEFINE CLASS events AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: complete		&& Fires when worker has finished executing command.
		*m: getdatasession		&& Return data session ID of events object.
		*m: loadcursor		&& Load cursor from temp table.
		*m: returncursor		&& Fires when Worker.ReturnCursor() is called on worker and after cursor has been loaded.
		*m: returndata		&& Fires when Worker.ReturnData() is called on worker.
		*m: returnerror		&& Return error to main process.
		*m: setdatasession		&& Set data session so events occur in same session as Parallel object.
		*m: updatecommandcount		&& Update number of commands currently running.
		*m: updateprogress		&& Fires when Worker.UpdateProgress() is called on worker.
		*p: ncommands		&& Number of commands currently queued or running.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Name = "events"
	ncommands = 0		&& Number of commands currently queued or running.
	_memberdata = <VFPData>
		<memberdata name="ncommands" display="nCommands"/>
		<memberdata name="complete" display="Complete"/>
		<memberdata name="updateprogress" display="UpdateProgress"/>
		<memberdata name="returndata" display="ReturnData"/>
		<memberdata name="returnerror" display="ReturnError"/>
		<memberdata name="updatecommandcount" display="UpdateCommandCount"/>
		<memberdata name="loadcursor" display="LoadCursor"/>
		<memberdata name="returncursor" display="ReturnCursor"/>
		<memberdata name="setdatasession" display="SetDataSession"/>
		<memberdata name="getdatasession" display="GetDataSession"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE complete		&& Fires when worker has finished executing command.
		Lparameters lvReturn
		
		Debugout Time(0), Program(), lvReturn
		
		This.nCommands = This.nCommands - 1 
		
	ENDPROC

	PROCEDURE getdatasession		&& Return data session ID of events object.
		* Return data session ID of events object.
		
		Return Set("Datasession")
	ENDPROC

	PROCEDURE loadcursor		&& Load cursor from temp table.
		* Load cursor from temp table.
		Lparameters lcAlias, lcTempFile
		Local lnCurrentArea, lcDBC
		
		Debugout Time(0), Program(), lcAlias, lcTempFile
		
		lnCurrentArea = Select()
		lcDBC = Dbc()
		
		Select * from (lcTempFile) ;
			into cursor (lcAlias) NoFilter ReadWrite
		
		* Close/erase temp files
		Set Database To (lcTempFile)
		Close Databases 
		Erase (lcTempFile + ".*")
		
		Set Database To (lcDBC)
		Select (lnCurrentArea)
		
		* Fire event
		This.ReturnCursor(lcAlias)
		
	ENDPROC

	PROCEDURE returncursor		&& Fires when Worker.ReturnCursor() is called on worker and after cursor has been loaded.
		* Fires when Worker.ReturnCursor() is called on worker and after cursor has been loaded.
		Lparameters lcAlias
		
		Debugout Time(0), Program(), lcAlias
	ENDPROC

	PROCEDURE returndata		&& Fires when Worker.ReturnData() is called on worker.
		* Fires when Worker.ReturnData() is called on worker.
		Lparameters tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24, tPar25, tPar26
			
		Debugout Time(0), Program(), tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24, tPar25, tPar26
	ENDPROC

	PROCEDURE returnerror		&& Return error to main process.
		* Return error to main process
		LPARAMETERS lnError, lcMethod, lnLine, lcMessage, lcCode
		
		Debugout Time(0), Program(), lnError, lcMethod, lnLine, lcMessage, lcCode
		
		This.nCommands = This.nCommands - 1 
		
	ENDPROC

	PROCEDURE setdatasession		&& Set data session so events occur in same session as Parallel object.
		* Set data session so events occur in same session as Parallel object.
		* BindEvent does not cause data session switch, so this object needs to be in same datasession
		Lparameters lnDataSession
		
		Try 
			Set Datasession To (lnDataSession)
		Catch
			* If data session not available, stay in current session
		EndTry 
	ENDPROC

	PROCEDURE updatecommandcount		&& Update number of commands currently running.
		* Update number of commands currently running.
		Lparameters llAllWorkers
		Local lnCommands
		
		If llAllWorkers
			lnCommands = _Screen.ParPoolMgr.nWorkerCount
		Else
			lnCommands = 1
		EndIf 
		
		This.nCommands = This.nCommands + lnCommands
		
	ENDPROC

	PROCEDURE updateprogress		&& Fires when Worker.UpdateProgress() is called on worker.
		* Send progress update to main process
		Lparameters lnProgress, lcMessage
		
		Debugout Time(0), Program(), lnProgress, lcMessage
	ENDPROC

ENDDEFINE

DEFINE CLASS frmerrorlist AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="edtErrorList" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: displayerror		&& Display error in list.
		*p: cerrorlist		&& List of errors.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AutoCenter = .T.
	Caption = "ParallelFox Worker Errors"
	cerrorlist = 		&& List of errors.
	DoCreate = .T.
	Height = 480
	Name = "frmerrorlist"
	Width = 640
	_memberdata = <VFPData>
		<memberdata name="displayerror" display="DisplayError"/>
		<memberdata name="cerrorlist" display="cErrorList"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'edtErrorList' AS editbox WITH ;
		Anchor = 15, ;
		ControlSource = "Thisform.cErrorList", ;
		Height = 478, ;
		Left = 1, ;
		Name = "edtErrorList", ;
		ReadOnly = .T., ;
		Top = 1, ;
		Width = 638
		*< END OBJECT: BaseClass="editbox" />
	
	PROCEDURE displayerror		&& Display error in list.
		* Display error in list.
		Lparameters lnError, lcMethod, lnLine, lcMessage, lcCode
		Local lcErrorMsg
		
		Text to lcErrorMsg TextMerge NoShow
		Error: <<lnError>>
		Message: <<lcMessage>>
		Method: <<lcMethod>>
		Line: <<lnLine>>
		<<Replicate("-",100)>>
		
		EndText 
		
		ThisForm.cErrorList = ThisForm.cErrorList + lcErrorMsg
		* ThisForm.edtErrorList.Value = ThisForm.edtErrorList.Value + lcErrorMsg
		ThisForm.edtErrorList.Refresh()
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS mainprocess AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: isrunning		&& Check if main process is still running. If not, quit worker.
		*m: starttimer		&& Start timer to periodically check that main process is still running.
		*p: omainvfp		&& Reference to _VFP object in main process.
		*p: otimer		&& Timer to periodically check that main process is still running.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Name = "mainprocess"
	omainvfp = .NULL.		&& Reference to _VFP object in main process.
	otimer = 		&& Timer to periodically check that main process is still running.
	_memberdata = <VFPData>
		<memberdata name="omainvfp" display="oMainVFP"/>
		<memberdata name="isrunning" display="IsRunning"/>
		<memberdata name="starttimer" display="StartTimer"/>
		<memberdata name="otimer" display="oTimer"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE isrunning		&& Check if main process is still running. If not, quit worker.
		* Check if main process is still running. If not, quit worker.
		This.oTimer.Enabled = .f.
		
		Debugout Time(0), Program()
		
		* No need to test main process when in MTDLL
		If _VFP.StartMode = 5
			Return .t.
		EndIf 
		
		Try 
			This.oMainVFP.Eval(1)
		Catch
			Quit 
		EndTry 
		
		This.oTimer.Enabled = .t.
		Return .t.
	ENDPROC

	PROCEDURE starttimer		&& Start timer to periodically check that main process is still running.
		* Start timer to periodically check that main process is still running.
		Local loTimer as Timer
		
		Debugout Time(0), Program()
		
		loTimer = CreateObject("Timer")
		BindEvent(loTimer, "Timer", This, "IsRunning")
		loTimer.Interval = 60000	&& check every minute
		
		This.oTimer = loTimer
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS parallel AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: bindevent		&& Bind to worker events: "Complete", "UpdateProgress", "ReturnData", "ReturnError".
		*m: call		&& Execute/call function on worker.
		*m: callmethod		&& Execute/call class method on worker.
		*m: clearqueue		&& Remove all pending commands from queue.
		*m: detecthyperthreading		&& Returns .T. when HyperThreading is enabled.
		*m: do		&& Execute program on worker.
		*m: docmd		&& Execute single command on worker.
		*m: execscript		&& Execute script on worker.
		*m: onerror		&& Set up global handler for worker errors. Available variables are nError, cMethod, nLine, cMessage, cCode. Example: Parallel.OnError("Do MyErrorHandler with nError, cMethod, nLine, cMessage, cCode")
		*m: setmultithreaded		&& Set .T. to use in-process multithreaded DLL workers. Otherwise, out-of-process EXEs are used.
		*m: setworkerclass		&& Change worker class from default. lcClass and lcLibrary are used in debug mode.
		*m: setworkercount		&& Set number of workers. Defaults to CPU count. Set before starting workers.
		*m: startworkers		&& Start worker processes.
		*m: stopworkers		&& Stop worker processes.
		*m: wait		&& Wait until workers have finished processing queued commands.
		*p: cpucount		&& Number of logical processors on machine.
		*p: _events		&& Use Parallel.BindEvent().
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	cpucount = 0		&& Number of logical processors on machine.
	Name = "parallel"
	_events = NULL		&& Use Parallel.BindEvent().
	_memberdata = <VFPData>
		<memberdata name="do" display="Do"/>
		<memberdata name="startworkers" display="StartWorkers"/>
		<memberdata name="cpucount" display="CPUCount"/>
		<memberdata name="setworkercount" display="SetWorkerCount"/>
		<memberdata name="docmd" display="DoCmd"/>
		<memberdata name="execscript" display="ExecScript"/>
		<memberdata name="call" display="Call"/>
		<memberdata name="bindevent" display="BindEvent"/>
		<memberdata name="wait" display="Wait"/>
		<memberdata name="_events" display="_Events"/>
		<memberdata name="callmethod" display="CallMethod"/>
		<memberdata name="stopworkers" display="StopWorkers"/>
		<memberdata name="onerror" display="OnError"/>
		<memberdata name="clearqueue" display="ClearQueue"/>
		<memberdata name="setworkerclass" display="SetWorkerClass"/>
		<memberdata name="detecthyperthreading" display="DetectHyperThreading"/>
		<memberdata name="setmultithreaded" display="SetMultiThreaded"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE bindevent		&& Bind to worker events: "Complete", "UpdateProgress", "ReturnData", "ReturnError".
		* Bind to worker events
		Lparameters cEvent, oEventHandler, cDelegate, nFlags
		
		Debugout Time(0), Program(), cEvent, cDelegate
		
		cEvent = Alltrim(cEvent)
		nFlags = Evl(nFlags, 0)
		
		* Unbind global error handler if overriding
		If Upper(cEvent) = "RETURNERROR"
			UnBindEvents(This._Events, "ReturnError", _Screen.ParPoolMgr, "HandleError")
		EndIf 
		
		BindEvent(This._Events, cEvent, oEventHandler, cDelegate, nFlags)
		
		
	ENDPROC

	PROCEDURE call		&& Execute/call function on worker.
		* Execute program on worker
		Lparameters cFunction, lAllWorkers, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24
		Local loParameters
		
		Debugout Time(0), Program(), cFunction, lAllWorkers, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24
			
		This._Events.UpdateCommandCount(lAllWorkers)
			
		loParameters = _Screen.ParPoolMgr.CreateParameterObject(Pcount()-2, @tPar1, @tPar2, @tPar3, @tPar4, ;
			@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
			@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
			@tPar19, @tPar20, @tPar21, @tPar22, @tPar23, @tPar24)
			
		_Screen.ParPoolMgr.QueueCommand("Call", cFunction,,,,loParameters, lAllWorkers, This._Events)
		
		
	ENDPROC

	PROCEDURE callmethod		&& Execute/call class method on worker.
		* Execute/call class method on worker.
		Lparameters cMethod, cClassName, cModule, cInApplication, lAllWorkers, ;
			tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21
		Local loParameters
		
		Debugout Time(0), Program(), cMethod, cClassName, cModule, cInApplication, lAllWorkers, ;
			tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21
			
		This._Events.UpdateCommandCount(lAllWorkers)
			
		loParameters = _Screen.ParPoolMgr.CreateParameterObject(Pcount()-5, @tPar1, @tPar2, @tPar3, @tPar4, ;
			@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
			@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
			@tPar19, @tPar20, @tPar21)
			
		_Screen.ParPoolMgr.QueueCommand("CallMethod", cMethod, cClassName, cModule, cInApplication, ;
			loParameters, lAllWorkers, This._Events)
		
	ENDPROC

	PROCEDURE clearqueue		&& Remove all pending commands from queue.
		* Remove all pending commands from queue.
		
		Debugout Time(0), Program()
		
		_Screen.ParPoolMgr.ClearQueue()
	ENDPROC

	PROCEDURE Destroy
		Debugout Time(0), Program()
		
		UnBindEvents(This)
		
	ENDPROC

	PROCEDURE detecthyperthreading		&& Returns .T. when HyperThreading is enabled.
		* Returns .T. when HyperThreading is Enabled.
		* Default value is NULL.  Detection is a little slow, so only run once.
		If IsNull(_Screen.ParPoolMgr.lHyperThreading)
			_Screen.ParPoolMgr.DetectHyperThreading()
		EndIf
		
		Return _Screen.ParPoolMgr.lHyperThreading
	ENDPROC

	PROCEDURE do		&& Execute program on worker.
		* Execute program on worker
		Lparameters cPRG, cInProgram, lAllWorkers, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23
		Local loParameters
		
		Debugout Time(0), Program(), cPRG, cInProgram, lAllWorkers, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23
		
		This._Events.UpdateCommandCount(lAllWorkers)
			
		loParameters = _Screen.ParPoolMgr.CreateParameterObject(Pcount()-3, @tPar1, @tPar2, @tPar3, @tPar4, ;
			@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
			@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
			@tPar19, @tPar20, @tPar21, @tPar22, @tPar23)
			
		_Screen.ParPoolMgr.QueueCommand("Do", cPRG, cInProgram,,,loParameters, lAllWorkers, This._Events)
		
	ENDPROC

	PROCEDURE docmd		&& Execute single command on worker.
		Lparameters cCommand, lAllWorkers
		
		Debugout Time(0), Program(), cCommand, lAllWorkers
		
		This._Events.UpdateCommandCount(lAllWorkers)
			
		_Screen.ParPoolMgr.QueueCommand("DoCmd", cCommand,,,,, lAllWorkers, This._Events)
	ENDPROC

	PROCEDURE execscript		&& Execute script on worker.
		* Execute script on worker
		Lparameters cScript, lAllWorkers, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24
		Local loParameters
		
		Debugout Time(0), Program(), "(Script)", lAllWorkers, tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24
			
		This._Events.UpdateCommandCount(lAllWorkers)
			
		loParameters = _Screen.ParPoolMgr.CreateParameterObject(Pcount()-2, @tPar1, @tPar2, @tPar3, @tPar4, ;
			@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
			@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
			@tPar19, @tPar20, @tPar21, @tPar22, @tPar23, @tPar24)
			
		_Screen.ParPoolMgr.QueueCommand("ExecScript", cScript,,,,loParameters, lAllWorkers, This._Events)
		
		
	ENDPROC

	PROCEDURE Init
		* Instantiate parallel pool manager
		If Type("_Screen.ParPoolMgr") <> "O" or IsNull(_Screen.ParPoolMgr)
			_Screen.NewObject("ParPoolMgr", "ParPoolMgr", "ParallelFox.vcx")
		EndIf 
		
		This.CPUCount = _Screen.ParPoolMgr.nCPUCount
		
		This._Events = NewObject("Events", "ParallelFox.vcx")
		This.BindEvent("ReturnError", _Screen.ParPoolMgr, "HandleError")
		
	ENDPROC

	PROCEDURE onerror		&& Set up global handler for worker errors. Available variables are nError, cMethod, nLine, cMessage, cCode. Example: Parallel.OnError("Do MyErrorHandler with nError, cMethod, nLine, cMessage, cCode")
		Lparameters cOnErrorCommand
		
		Debugout Time(0), Program(), cOnErrorCommand
		
		_Screen.ParPoolMgr.cOnError = cOnErrorCommand
	ENDPROC

	PROCEDURE setmultithreaded		&& Set .T. to use in-process multithreaded DLL workers. Otherwise, out-of-process EXEs are used.
		* Set .T. to use in-process multithreaded DLL workers. Otherwise, out-of-process EXEs are used.
		* Must be set before StartWorkers is called.
		Lparameters llMTDLL
		
		_Screen.ParPoolMgr.lMTDLL = llMTDLL
		
	ENDPROC

	PROCEDURE setworkerclass		&& Change worker class from default. lcClass and lcLibrary are used in debug mode.
		* Change worker class from default. lcClass and lcLibrary are used in debug mode.
		Lparameters cCOMProgID, cClass, cLibrary
		
		Debugout Time(0), Program(), cCOMProgID, cClass, cLibrary
		
		_Screen.ParPoolMgr.cWorkerCOMProgID = cCOMProgID
		_Screen.ParPoolMgr.cWorkerClass = cClass
		_Screen.ParPoolMgr.cWorkerLibrary = cLibrary
	ENDPROC

	PROCEDURE setworkercount		&& Set number of workers. Defaults to CPU count. Set before starting workers.
		* Set number of workers. 
		* Defaults to CPU count. 
		* Set before starting workers.
		Lparameters nWorkerCount, nTerminalServerCount
		
		_Screen.ParPoolMgr.SetWorkerCount(nWorkerCount, nTerminalServerCount)
		
		
	ENDPROC

	PROCEDURE startworkers		&& Start worker processes.
		* Start worker processes
		* Same EXE is used for all workers
		Lparameters cProcedureFile, cDirectory, lDebugMode
		
		Debugout Time(0), Program(), cProcedureFile, cDirectory, lDebugMode
		
		_Screen.ParPoolMgr.StartWorkers(cProcedureFile, cDirectory, lDebugMode)
	ENDPROC

	PROCEDURE stopworkers		&& Stop worker processes.
		* Stop worker processes
		* Pass .T. to stop worker processes immediately. Otherwise, existing commands will finish first.
		Lparameters lStopImmediately
		
		Debugout Time(0), Program(), lStopImmediately
		
		If lStopImmediately
			_Screen.ParPoolMgr.StopWorkers()
		Else
			_Screen.ParPoolMgr.QueueCommand("StopWorkers")
		EndIf 
	ENDPROC

	PROCEDURE wait		&& Wait until workers have finished processing queued commands.
		* Wait until workers have finished processing queued commands.
		Lparameters lAllWorkers
		
		Debugout Time(0), Program(), "Start"
		
		Local lnKey
		lnKey = 0
		Do while .t.
			* Sleep() blocks worker processes, so use INKEY() to wait
			Try 
				lnKey = Inkey(.1, "H")
			Catch
				* INKEY() crashes intermittently. If that happens, use Chrsaw().
				lnKey = 0
				If Chrsaw(.1)
					lnKey = Inkey()
				EndIf 
			EndTry 	
		
			Do Case
			* ON Escape doesn't work during INKEY() and VFP can appear locked up.
			* CTRL+X will force exit from Wait.
			Case lnKey = 24
				Exit 
			* Wait for commands from current instance of Parallel object
			Case !lAllWorkers and !(This._Events.nCommands > 0 and _Screen.ParPoolMgr.nBusyWorkers > 0)
				Exit 
			* Wait for commands from all instances of Parallel object
			Case lAllWorkers and !(_Screen.ParPoolMgr.nBusyWorkers > 0 ;
					or (Type("_Screen.ParPoolMgr.CommandQueue.Count") = "N" and _Screen.ParPoolMgr.CommandQueue.Count > 0))
				Exit 
			EndCase 
		EndDo 
		
		Debugout Time(0), Program(), "Complete"
	ENDPROC

ENDDEFINE

DEFINE CLASS parameters AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: copyarray		&& Copy array to worker.
		*m: isarray		&& Returns .T. if specified parameter is an array.
		*p: npcount		&& Number of parameters.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Name = "parameters"
	npcount = 0		&& Number of parameters.
	_memberdata = <VFPData>
		<memberdata name="npcount" display="nPCount"/>
		<memberdata name="isarray" display="IsArray"/>
		<memberdata name="copyarray" display="CopyArray"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE copyarray		&& Copy array to worker.
		* Copy array to worker.
		* ACOPY doesn't work when run from worker on array that is COM object property.
		* Must pass array as parameter to worker.
		Lparameters lcParameter, loManager as aManager of ParallelFox.vcx
		Local lcArray
		Local array laTemp[1]
		
		lcArray = "This." + lcParameter
		Acopy(&lcArray, laTemp)
		
		loManager.CopyArray(@laTemp)
	ENDPROC

	PROCEDURE isarray		&& Returns .T. if specified parameter is an array.
		* Returns .T. if specified parameter is an array.
		* Type("aArray", 1) does not work when called from worker.
		Lparameters lcParameter
		Local llIsArray
		
		lcParameter = "This." + lcParameter
		llIsArray = (Type(lcParameter, 1) = "A")
		
		Return llIsArray
		
	ENDPROC

ENDDEFINE

DEFINE CLASS parpoolmgr AS amanager OF "parallelfox.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: clearqueue		&& Remove all pending commands from queue.
		*m: displayerrors		&& Default error handler displays list of errors from workers.
		*m: handleerror		&& Global Error Handler.
		*m: processqueue		&& Process command queue.
		*m: queuecommand		&& Add command to queue.
		*m: setworkercount		&& Sets number for workers.
		*m: startworkers		&& Start worker processes.
		*m: stopworkers		&& Stop worker processes.
		*p: commandqueue		&& Command queue collection.
		*p: conerror		&& On Error command.
		*p: cworkerclass		&& Worker class name (used in debug mode).
		*p: cworkercomprogid		&& COM ProgID for worker class.
		*p: cworkerlibrary		&& Worker class library (used in debug mode).
		*p: ldebugmode		&& Start workers in Debug mode.
		*p: lmtdll		&& Set .T. to use in-process multithreaded DLL workers. Otherwise, out-of-process EXEs are used.
		*p: nbusyworkers		&& Number of workers currently processing commands.
		*p: ncpucount		&& Number of logical processors on machine.
		*p: nprocessing		&& Number of times ProcessQueue has been called.
		*p: nworkercount		&& Number of workers. Defaults to CPU count.
		*p: oerrorlist		&& Reference to error list form.
		*p: workers		&& Workers collection.
	*</DefinedPropArrayMethod>

	PROTECTED ldebugmode,nprocessing
	commandqueue = 		&& Command queue collection.
	conerror = This.DisplayErrors(nError, cMethod, nLine, cMessage, cCode)		&& On Error command.
	cworkerclass = WorkerMgr		&& Worker class name (used in debug mode).
	cworkercomprogid = ParallelFox.WorkerMgr		&& COM ProgID for worker class.
	cworkerlibrary = ParallelFox.vcx		&& Worker class library (used in debug mode).
	ldebugmode = .F.		&& Start workers in Debug mode.
	lmtdll = .F.		&& Set .T. to use in-process multithreaded DLL workers. Otherwise, out-of-process EXEs are used.
	Name = "parpoolmgr"
	nbusyworkers = 0		&& Number of workers currently processing commands.
	ncpucount = 0		&& Number of logical processors on machine.
	nprocessing = 0		&& Number of times ProcessQueue has been called.
	nworkercount = 0		&& Number of workers. Defaults to CPU count.
	oerrorlist = .NULL.		&& Reference to error list form.
	workers = .NULL.		&& Workers collection.
	_memberdata = <VFPData>
		<memberdata name="ncpucount" display="nCPUCount"/>
		<memberdata name="nworkercount" display="nWorkerCount"/>
		<memberdata name="startworkers" display="StartWorkers"/>
		<memberdata name="workers" display="Workers"/>
		<memberdata name="nbusyworkers" display="nBusyWorkers"/>
		<memberdata name="queuecommand" display="QueueCommand"/>
		<memberdata name="processqueue" display="ProcessQueue"/>
		<memberdata name="commandqueue" display="CommandQueue"/>
		<memberdata name="ldebugmode" display="lDebugMode"/>
		<memberdata name="stopworkers" display="StopWorkers"/>
		<memberdata name="handleerror" display="HandleError"/>
		<memberdata name="conerror" display="cOnError"/>
		<memberdata name="clearqueue" display="ClearQueue"/>
		<memberdata name="cworkercomprogid" display="cWorkerCOMProgID"/>
		<memberdata name="cworkerclass" display="cWorkerClass"/>
		<memberdata name="cworkerlibrary" display="cWorkerLibrary"/>
		<memberdata name="nprocessing" display="nProcessing"/>
		<memberdata name="setworkercount" display="SetWorkerCount"/>
		<memberdata name="displayerrors" display="DisplayErrors"/>
		<memberdata name="oerrorlist" display="oErrorList"/>
		<memberdata name="lmtdll" display="lMTDLL"/>
		</VFPData>
	
	PROCEDURE clearqueue		&& Remove all pending commands from queue.
		* Remove all pending commands from queue.
		
		Debugout Time(0), Program()
		
		This.CommandQueue = NULL
		This.CommandQueue = CreateObject("Collection")
		
		This.nProcessing = 0
	ENDPROC

	PROCEDURE displayerrors		&& Default error handler displays list of errors from workers.
		* Default error handler displays list of errors from workers.
		Lparameters lnError, lcMethod, lnLine, lcMessage, lcCode
		
		If Vartype(This.oErrorList) <> "O" or IsNull(This.oErrorList)
			This.oErrorList = NewObject("frmErrorList", "ParallelFox.vcx")
			This.oErrorList.Show()
		EndIf 
		
		This.oErrorList.DisplayError(lnError, lcMethod, lnLine, lcMessage, lcCode)
	ENDPROC

	PROCEDURE handleerror		&& Global Error Handler.
		* Global error handler. Set up with Parallel.OnError()
		Lparameters nError, cMethod, nLine, cMessage, cCode
		Local lcOnError
		
		Debugout Time(0), Program(), nError, cMethod, nLine, cMessage, cCode
		
		lcOnError = This.cOnError
		&lcOnError
		
	ENDPROC

	PROCEDURE Init
		* Number of logical processors on machine.
		This.nCPUCount = Evl(Val(GetEnv("NUMBER_OF_PROCESSORS")), 1)
		This.SetWorkerCount(This.nCPUCount, 1)
		
		This.Workers = CreateObject("Collection")
		This.CommandQueue = CreateObject("Collection")
		
		Return DoDefault()
	ENDPROC

	PROCEDURE processqueue		&& Process command queue.
		Local lnCommands, lnCommand, loWorkerProxy as WorkerProxy of ParallelFox.vcx, ;
			lnCommandNum, llSendCommand, lnWorker
		
		* This method can be interrupted and called again by worker events
		* Make sure it completely finishes before calling again
		* nProcessing=0 means ProcessQueue is not currently running and queue can be processed now
		* nProcessing=1 means ProcessQueue is currently running
		* nProcessing=2 means run ProcessQueue again at the end of the current run
		* Need to do evaluation and assignment in single line of code so it doesn't get interrupted (hope this works)
		If Iif(This.nProcessing > 0, ;
				This.WriteExpression("nProcessing", "2"), ;
				!This.WriteExpression("nProcessing", "1"))
			* Queue is currently being processed, so set flag to process again and return
			Debugout Time(0), Program(), "Already processing. Will process again."	
			Return
		EndIf 
		
		* Prevent error if run in the middle of CLEAR ALL
		If Type("This.Workers.Count") = "U" or Type("This.CommandQueue.Count") = "U"
			? "Exiting ProcessQueue"
			Return 
		EndIf 
		
		* Release completed workers for more work
		* Previously, this was done directly by WorkerProxy, 
		*	but that allowed commands to be sent out of order
		If This.nBusyWorkers > 0 
			For each loWorkerProxy in This.Workers FoxObject
				If loWorkerProxy.lBusy and loWorkerProxy.lComplete
					loWorkerProxy.lBusy = .f.
					loWorkerProxy.lComplete = .f.
					This.nBusyWorkers = This.nBusyWorkers - 1 
				EndIf 
			EndFor 
		EndIf 
		
		* Stop workers
		If This.nBusyWorkers = 0 and This.CommandQueue.Count = 1 ;
				and Upper(This.CommandQueue(1).cCommandType) = "STOPWORKERS"
			This.StopWorkers()
			Return 
		EndIf 
		
		* Return if all workers busy
		If This.nBusyWorkers >= This.Workers.Count or This.CommandQueue.Count = 0
			Debugout Time(0), Program(), "No workers or commands available", This.nBusyWorkers, This.CommandQueue.Count
			* Process again if necessary
			* Need to do evaluation and assignment in single line of code so it doesn't get interrupted
			If Iif(This.nProcessing > 1, ;
					This.WriteExpression("nProcessing", "0"), ;
					!This.WriteExpression("nProcessing", "0"))
				Debugout Time(0), Program(), "Processing again."	
				This.ProcessQueue()
			EndIf 
			Return
		EndIf 
		
		Debugout Time(0), Program(), "---- Process Queue Start ----"
		
		lnCommands = This.CommandQueue.Count
		lnCommandNum = 1
		For lnCommand = 1 to lnCommands
		
			If This.nBusyWorkers >= This.Workers.Count or Upper(This.CommandQueue(lnCommandNum).cCommandType) = "STOPWORKERS"
				Exit 
			EndIf 
			
			llSendCommand = .f.
			
			* Which worker to run on can be specified.  0 means next available. Used to run a command on all workers.
			lnWorker = This.CommandQueue(lnCommandNum).nWorker
			If !Empty(lnWorker)
				loWorkerProxy = This.Workers(lnWorker)
				If !loWorkerProxy.lBusy
					loWorkerProxy.lLocked = .f.
					llSendCommand = .t.
				Else
					* If specific worker is busy, we'll try again next time
					* Lock worker so it can't be used by other commands
					loWorkerProxy.lLocked = .t.
					lnCommandNum = lnCommandNum + 1 
				EndIf 
			Else 
				* Find worker that is not busy or locked
				For each loWorkerProxy in This.Workers FoxObject
					If !loWorkerProxy.lBusy and !loWorkerProxy.lLocked
						llSendCommand = .t.
						Exit 
					EndIf 
				EndFor 
			EndIf 
			
			If llSendCommand 
				* Mark worker as busy
				loWorkerProxy.lBusy = .t.
				This.nBusyWorkers = This.nBusyWorkers + 1 
				* Send command to worker
				loWorkerProxy.SendCommand(This.CommandQueue(lnCommandNum))
				* Delete command from queue
				This.CommandQueue.Remove(lnCommandNum)
			EndIf 
		
		EndFor 
		
		Debugout Time(0), Program(), "---- Process Queue End ----"
		
		* Process again if necessary
		* Need to do evaluation and assignment in single line of code so it doesn't get interrupted
		If Iif(This.nProcessing > 1, ;
				This.WriteExpression("nProcessing", "0"), ;
				!This.WriteExpression("nProcessing", "0"))
			Debugout Time(0), Program(), "Processing again."	
			This.ProcessQueue()
		EndIf 
		
	ENDPROC

	PROCEDURE queuecommand		&& Add command to queue.
		* Add command to queue.
		Lparameters lcCommandType, lcCommand, lcClass, lcModule, lcInApplication, ;
			loParameters, llAllWorkers, loEvents
		Local loCommand as Command of ParallelFox.vcx, lnWorker, lnWorkerCnt
		
		Debugout Time(0), Program(), lcCommandType, lcCommand, lcClass, lcModule, ;
			lcInApplication, llAllWorkers
		
		If llAllWorkers
			* Queue command for all workers
			lnWorkerCnt = This.nWorkerCount
		Else
			* Queue for next available worker
			lnWorkerCnt = 1
		EndIf 
		
		For lnWorker = 1 to lnWorkerCnt 
			* Create command object
			loCommand = NewObject("Command", "ParallelFox.vcx")
			loCommand.cCommandType = Evl(lcCommandType, "")
			loCommand.cCommand = Evl(lcCommand, "")
			loCommand.cClass = Evl(lcClass, "")
			loCommand.cModule = Evl(lcModule, "")
			loCommand.cInApplication = Evl(lcInApplication, "")
			loCommand.oParameters = loParameters
			loCommand.oEvents = loEvents
			If llAllWorkers
				loCommand.nWorker = lnWorker
			EndIf 
			* Add to queue
			This.CommandQueue.Add(loCommand)
		EndFor 
		
		This.ProcessQueue()
		 
	ENDPROC

	PROCEDURE setworkercount		&& Sets number for workers.
		* Set number of workers. 
		* Defaults to CPU count. 
		* Set before starting workers.
		Lparameters lnWorkerCount, lnTerminalServerCount
		
		Debugout Time(0), Program(), lnWorkerCount, lnTerminalServerCount
		
		lnWorkerCount = Evl(lnWorkerCount, 0)
		lnTerminalServerCount = Evl(lnTerminalServerCount, 0)
		
		If Bittest(Val(Os(10)), 4) and !Bittest(Val(Os(10)), 8)	&& Terminal Server with multiple users
			This.nWorkerCount = Max(Round(lnTerminalServerCount, 0), 1)
		Else 
			This.nWorkerCount = Max(Round(lnWorkerCount, 0), 1)
		EndIf 
		
	ENDPROC

	PROCEDURE startworkers		&& Start worker processes.
		* Start worker processes
		* Same EXE is used for all workers
		Lparameters lcProcedureFile, lcDirectory, llDebugMode
		Local lnWorker, loWorkerProxy as WorkerProxy of ParallelFox.vcx
		
		Debugout Time(0), Program(), lcProcedureFile, lcDirectory, llDebugMode
		
		If This.Workers.Count > 0
			Assert .f. Message "Workers already started."
			Return
		EndIf 
		
		This.lDebugMode = llDebugMode
		
		For lnWorker = 1 to This.nWorkerCount
			loWorkerProxy = NewObject("WorkerProxy", "ParallelFox.vcx", "", lcProcedureFile, lcDirectory, llDebugMode, lnWorker, This.lMTDLL)
			ComArray(loWorkerProxy, 11)
			This.Workers.Add(loWorkerProxy)
		EndFor 
		
	ENDPROC

	PROCEDURE stopworkers		&& Stop worker processes.
		* Stop worker processes
		Local loWorkerProxy as WorkerProxy of ParallelFox.vcx
		
		Debugout Time(0), Program()
		
		* Release workers
		For each loWorkerProxy in This.Workers FoxObject
			loWorkerProxy.StopWorker()
		EndFor 
		
		This.Workers = NULL
		This.Workers = CreateObject("Collection")
		This.nBusyWorkers = 0
		
		* Clear command queue
		This.ClearQueue()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS threadhandler AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: createthread		&& Create thread for MTDLL.
		*m: release		&& Release thread and object references.
		*m: sendcommand		&& Send command to worker thread.
		*m: startthread		&& Start thread for MTDLL worker.
		*m: stopthread		&& Stop thread used in MTDLL.
		*p: cmtscript		&& Startup/Stop script for MTDLL worker.
		*p: cworkercomprogid		&& MTDLL COM Prog ID.
		*p: lreleaseprocessed		&& Is set to .T. when Release() is processed, so it will only be processed once.
		*p: neventhandle		&& Handle for Win32 events sent to MTDLL to process a command.
		*p: nthreadhandle		&& Thread Handle.
		*p: nthreadid		&& Thread ID.
		*p: ocommand		&& Command object for MTDLL worker.
		*p: oevents		&& Reference to worker events object.
		*p: oreleasetimer		&& Timer used to call Release().
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lreleaseprocessed,nthreadhandle,nthreadid,oreleasetimer
	cmtscript = 		&& Startup/Stop script for MTDLL worker.
	cworkercomprogid = ParallelFoxMT.Application		&& MTDLL COM Prog ID.
	lreleaseprocessed = .F.		&& Is set to .T. when Release() is processed, so it will only be processed once.
	Name = "threadhandler"
	neventhandle = 0		&& Handle for Win32 events sent to MTDLL to process a command.
	nthreadhandle = 0		&& Thread Handle.
	nthreadid = 0		&& Thread ID.
	ocommand = .NULL.		&& Command object for MTDLL worker.
	oevents = .NULL.		&& Reference to worker events object.
	oreleasetimer = 		&& Timer used to call Release().
	_memberdata = <VFPData>
		<memberdata name="nthreadhandle" display="nThreadHandle"/>
		<memberdata name="cmtscript" display="cMTScript"/>
		<memberdata name="neventhandle" display="nEventHandle"/>
		<memberdata name="nthreadid" display="nThreadID"/>
		<memberdata name="startthread" display="StartThread"/>
		<memberdata name="createthread" display="CreateThread"/>
		<memberdata name="cworkercomprogid" display="cWorkerCOMProgID"/>
		<memberdata name="stopthread" display="StopThread"/>
		<memberdata name="release" display="Release"/>
		<memberdata name="lreleaseprocessed" display="lReleaseProcessed"/>
		<memberdata name="oreleasetimer" display="oReleaseTimer"/>
		<memberdata name="sendcommand" display="SendCommand"/>
		<memberdata name="oevents" display="oEvents"/>
		<memberdata name="ocommand" display="oCommand"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROTECTED PROCEDURE createthread		&& Create thread for MTDLL.
		* Create thread for MTDLL using Christof's DMULT
		Lparameters lcWorkerCOMProgID
		Local lnThreadID
		
		Declare Long CreateThreadWithObject in DMult.DLL ;
			String lpszClass, ;
			String lpszMethod, ;
			Object oRef,  ;
			Long @lpdwThreadId 
		
		* Create event 
		* Win32 event is sent to MTDLL when main thread is ready to process another command
		DECLARE INTEGER CreateEvent IN kernel32;
		    INTEGER lpEventAttributes, INTEGER bManualReset,;
		    INTEGER bInitialState, STRING lpName
		 
		DECLARE INTEGER SetEvent IN kernel32 INTEGER hEvent
		
		This.nEventHandle = CreateEvent (0, 0, 0, 0)
		
		* Create COM reference that can be passed to thread
		Local loCOMRef
		loCOMRef = _VFP.Eval("This")
		
		* Create thread 
		lnThreadID = 0
		This.nThreadHandle = CreateThreadWithObject( ;
			Strconv(lcWorkerCOMProgID + Chr(0),5), ;
			Strconv("StartMTWorker" + Chr(0),5), ;
			loCOMRef, ;
			@lnThreadID)
		
		This.nThreadID = lnThreadID
		
		
	ENDPROC

	PROCEDURE Destroy
		Debugout Time(0), "(" + Transform(This.nThreadHandle) + ")", Program()
		
		This.StopThread()
	ENDPROC

	PROCEDURE release		&& Release thread and object references.
		* Release thread and object references
		* Called by timer so thread has a chance to close normally before this method is called
		Local lnThreadExitCode, lnThreadCheck
		Debugout Time(0), "(" + Transform(This.nThreadHandle) + ")", Program()
		
		#DEFINE STILL_ALIVE 259
		
		If This.lReleaseProcessed
			Return 
		EndIf 
		This.lReleaseProcessed= .t.
		This.oReleaseTimer = NULL
		
		DECLARE INTEGER GetExitCodeThread IN kernel32;
		    INTEGER hThread,;
		    LONG @lpExitCode
		
		* If thread is still alive, give it a chance to stop normally before terminating
		For lnThreadCheck = 1 to 10
			lnThreadExitCode = 0
			GetExitCodeThread(This.nThreadHandle, @lnThreadExitCode)
			If lnThreadExitCode <> STILL_ALIVE
				Exit
			EndIf 
			
			* Give DMULT a chance to unload worker normally
			Inkey(.1, "H")
		EndFor 
			
		* Kill thread if it is still running
		* Heavy handed, but otherwise VFP will crash, especially after CLEAR ALL
		If lnThreadExitCode = STILL_ALIVE
			Declare Long TerminateThread IN kernel32 ;
				Long hThread, Long dwExitCode				
		 	TerminateThread(This.nThreadHandle, 0)
		EndIf 
		
		Declare CloseHandle in Win32API LONG
			
		CloseHandle(This.nEventHandle)
		CloseHandle(This.nThreadHandle)
		
		* Release dangling COM reference to this object
		Local loCOMRef
		loCOMRef = _VFP.Eval("This")
		Sys(3098, loComRef)
		
	ENDPROC

	PROCEDURE sendcommand		&& Send command to worker thread.
		Lparameters loCommand as Command of ParallelFox.vcx
		
		* Set command, then send event so MTDLL worker will grab command from main process
		This.oCommand = loCommand
		SetEvent(This.nEventHandle)
		
	ENDPROC

	PROCEDURE startthread		&& Start thread for MTDLL worker.
		* Start thread for MTDLL worker
		Lparameters lcDirectory, lcWorkerVCX, lcWorkerApp, lcProcedureFile
		
		* Start startup script for MTDLL worker
		Text to This.cMTScript TEXTMERGE NOSHOW 
			Lparameters loThreadHandler as ThreadHandler of ParallelFox.vcx
			Local loWorkerMgr as WorkerMgr of ParallelFox.vcx, loException as Exception, lcException
			Try 
				CD <<lcDirectory>>
				loWorkerMgr = NewObject("<<_Screen.ParPoolMgr.cWorkerClass>>", "<<lcWorkerVCX>>", "<<lcWorkerApp>>")
				* Not sure how I discovered this. Every object in VFP has a hidden Application property that
				*	points to _VFP/Application in the process where it runs.
				loWorkerMgr.SetMainProcess(loThreadHandler.Application, "<<lcWorkerApp>>")
				If !Empty("<<lcProcedureFile>>")
					Set Procedure To "<<lcProcedureFile>>" Additive
				EndIf 
			Catch to loException
				loThreadHandler.oEvents.ReturnError(loException.ErrorNo, "Thread startup script: " + loException.Procedure, loException.LineNo, ;
					loException.Message, loException.LineContents)
			EndTry 
			loWorkerMgr.StartMTCommandLoop(loThreadHandler)
		EndText 
		
		This.CreateThread(This.cWorkerCOMProgID)
		
	ENDPROC

	PROCEDURE stopthread		&& Stop thread used in MTDLL.
		* Stop thread used in MTDLL
		This.cMTScript = "STOPWORKER"
		SetEvent(This.nEventHandle)
			
		* Use timer to release thread
		* This gives thread a chance to process STOPWORKER command before thread is released
		If !This.lReleaseProcessed
			Local loTimer as Timer
			loTimer = CreateObject("Timer")
			loTimer.Interval = 1
			BindEvent(loTimer, "Timer", This, "Release")
			This.oReleaseTimer = loTimer
			loTimer.Enabled = .t.
		EndIf 
		
	ENDPROC

ENDDEFINE

DEFINE CLASS tmrcommand AS timer 
 	*< CLASSDATA: Baseclass="timer" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: processcommand		&& Process current command.
		*p: lprocessed		&& Is .T. if command already processed.
		*p: omanager		&& Manager class that processes command.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Enabled = .F.
	Height = 23
	Interval = 1
	lprocessed = 		&& Is .T. if command already processed.
	Name = "tmrcommand"
	omanager = .NULL.		&& Manager class that processes command.
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="processcommand" display="ProcessCommand"/>
		<memberdata name="lprocessed" display="lProcessed"/>
		<memberdata name="omanager" display="oManager"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE processcommand		&& Process current command.
		* Process current command
		Lparameters loManager
		
		This.oManager = loManager
		This.lProcessed = .f.
		This.Enabled = .t.
		
	ENDPROC

	PROCEDURE Timer
		* Worker Command timer
		* Timer is used to process command so main thread does not
		*	wait on command to complete.
		* Timer is enabled for each command and only fires once.
		Local loManager
		
		This.Enabled = .f.
		Doevents 
		* Timer can fire more than once before it is disabled.
		* Doevents usually prevents this from happening, but this code ensures it.
		If This.lProcessed
			Return 
		EndIf 
		This.lProcessed = .t.
		
		* Hold reference to manager for minimum time to help avoid dangling objects
		loManager = This.oManager
		This.oManager = NULL
		loManager.ProcessCommand() 
		
	ENDPROC

ENDDEFINE

DEFINE CLASS worker AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: endcriticalsection		&& End Critical Section of code.
		*m: isworker		&& Returns .T. if currently running in Worker process.
		*m: returncursor		&& Return cursor to main process.
		*m: returndata		&& Return data to main process. Due to limitations with VFP BindEvent(), arrays are not supported and cannot be returned.
		*m: returnerror		&& Return error to main process.
		*m: sleep		&& Pause execution if machine contains the specified number CPUs or fewer. Omit lnCPUCount (or pass 0) to pause regardless of CPUs.
		*m: startcriticalsection		&& Start Critical Section of code. Use a unique (but not random) name for each critical section.
		*m: updateprogress		&& Send progress update to main process. Pass .T. to llForceUpdate to disregard Worker.ProgressInterval.
		*p: cpucount		&& Number of logical processors on machine.
		*p: progressinterval		&& Minimum number of seconds between progress updates (default is 1 second).
		*a: _criticalsections[1,2]		&& Use Worker.StartCriticalSection().
		*p: _lastprogressupdate		&& Time of last progress update sent to main process.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED _lastprogressupdate
	cpucount = 0		&& Number of logical processors on machine.
	Name = "worker"
	progressinterval = 1		&& Minimum number of seconds between progress updates (default is 1 second).
	_lastprogressupdate = 0		&& Time of last progress update sent to main process.
	_memberdata = <VFPData>
		<memberdata name="updateprogress" display="UpdateProgress"/>
		<memberdata name="progressinterval" display="ProgressInterval"/>
		<memberdata name="_lastprogressupdate" display="_LastProgressUpdate"/>
		<memberdata name="returndata" display="ReturnData"/>
		<memberdata name="startcriticalsection" display="StartCriticalSection"/>
		<memberdata name="endcriticalsection" display="EndCriticalSection"/>
		<memberdata name="_criticalsections" display="_CriticalSections"/>
		<memberdata name="sleep" display="Sleep"/>
		<memberdata name="cpucount" display="CPUCount"/>
		<memberdata name="returnerror" display="ReturnError"/>
		<memberdata name="isworker" display="IsWorker"/>
		<memberdata name="returncursor" display="ReturnCursor"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Destroy
		* End any active critical sections
		Local lnRows, lnRow, lnhMutex 
		
		Debugout Time(0), Program()
		
		lnRows = Alen(This._CriticalSections, 1)
		For lnRow = 1 to lnRows
			lnhMutex = This._CriticalSections[lnRow,2]
			If !Empty(lnhMutex)
				ReleaseMutex(lnhMutex)
			EndIf 
		EndFor 
		
		
	ENDPROC

	PROCEDURE endcriticalsection		&& End Critical Section of code.
		* End Critical Section of code.
		Lparameters cCriticalSectionName
		Local lnhMutex, lnRow
		
		Debugout Time(0), Program(), cCriticalSectionName
		
		* Find and release mutex
		lnRow = Ascan(This._CriticalSections, cCriticalSectionName, 1, 0, 1, 8)
		If lnRow <> 0
			lnhMutex = This._CriticalSections[lnRow,2]
			ReleaseMutex(lnhMutex)
		
			* Remove from array
			Adel(This._CriticalSections, lnRow)
		EndIf 
	ENDPROC

	PROCEDURE Init
		* Number of logical processors on machine.
		This.CPUCount = Evl(Val(GetEnv("NUMBER_OF_PROCESSORS")), 1)
		
		* Load DLLs
		DECLARE Sleep IN kernel32 INTEGER dwMilliseconds
		
		DECLARE INTEGER CreateMutex IN kernel32;
		    INTEGER lpMutexAttributes,;
		    INTEGER bInitialOwner,;
		    STRING  lpName
		    
		DECLARE INTEGER WaitForSingleObject IN kernel32;
		    INTEGER hHandle,;
		    INTEGER dwMilliseconds
		   
		DECLARE INTEGER ReleaseMutex IN kernel32;
		    INTEGER hMutex
		
		
	ENDPROC

	PROCEDURE isworker		&& Returns .T. if currently running in Worker process.
		* Returns .T. if currently running in Worker process.
		
		Return Type("_Screen.oWorkerEvents") = "O"
	ENDPROC

	PROCEDURE returncursor		&& Return cursor to main process.
		* Return cursor to main process.
		Lparameters cAlias
		Local cDirectory, lcTempName, lcTempFile, lnCurrentArea, lcDBC
		
		cAlias = Evl(cAlias, Alias())
		cDirectory = Evl(cDirectory, Sys(2023))
		
		Do while .t.
			* Sys(2015) may actually return the same value in separate processes
			* Add ThreadID to the name to make sure it is unique across all workers
			lcTempName = Sys(2015) + "_" + Transform(_VFP.ThreadId)
			lcTempFile = Addbs(cDirectory) + lcTempName
			If !File(lcTempFile + ".dbf") and !File(lcTempFile + ".dbc")
				Exit
			EndIf
		EndDo 
		
		* Create database to support long field names
		lcDBC = Dbc()
		If !DBused(lcDBC)	
			* Full path may not work if DBC is compiled into EXE/APP
			lcDBC = JustStem(JustFname(lcDBC))
		EndIf 
		lnCurrentArea = Select()
		Create Database (lcTempFile)
		
		* Copy cursor to temp table
		Select (cAlias)
		Copy To (lcTempFile) Database (lcTempFile)
		
		Set Database To (lcTempFile)
		Close Databases 
		Set Database To (lcDBC)
		Select (lnCurrentArea)
		
		If _Screen.oMainProcess.IsRunning() and Type("_Screen.oWorkerEvents.Name") = "C"
			_Screen.oWorkerEvents.LoadCursor(cAlias, lcTempFile)
		EndIf 
		
	ENDPROC

	PROCEDURE returndata		&& Return data to main process. Due to limitations with VFP BindEvent(), arrays are not supported and cannot be returned.
		* Return data to main process.
		* BindEvent() does not work with parameters passed by reference, so all parameters must be
		*	passed by value.  This prevents arrays from being supported.
		Lparameters tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24, tPar25, tPar26
		Local lnPCount, lnParameter, lcParameter, lcParameterClause
		
		Debugout Time(0), Program(), tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24, tPar25, tPar26
		
		* Build parameter clause
		lcParameterClause = ""
		lnPCount = Pcount()
		For lnParameter = 1 to lnPCount
			* Pass parameters by reference in case passed by reference to this method
			lcParameter = "tPar" + Transform(lnParameter)
			If !Empty(lcParameterClause)
				lcParameterClause = lcParameterClause + ", "
			EndIf 
			lcParameterClause = lcParameterClause + lcParameter
		EndFor 
		
		If _Screen.oMainProcess.IsRunning() and Type("_Screen.oWorkerEvents.Name") = "C"
			_Screen.oWorkerEvents.ReturnData(&lcParameterClause)
		EndIf 
		
	ENDPROC

	PROCEDURE returnerror		&& Return error to main process.
		* Return error to main process.
		Lparameters nError, cMethod, nLine, cMessage, cCode
		
		Debugout Time(0), Program(), nError, cMethod, nLine, cMessage, cCode
		
		If _Screen.oMainProcess.IsRunning() and Type("_Screen.oWorkerEvents.Name") = "C"
			_Screen.oWorkerEvents.ReturnError(nError, cMethod, nLine, cMessage, cCode)
		EndIf 
		
	ENDPROC

	PROCEDURE sleep		&& Pause execution if machine contains the specified number CPUs or fewer. Omit lnCPUCount (or pass 0) to pause regardless of CPUs.
		* Pause execution if machine contains the specified number CPUs or fewer. 
		* Omit lnCPUCount (or pass 0) to pause regardless of CPUs.
		Lparameters nMilliseconds, nCPUCount
		
		nMilliseconds = Evl(nMilliseconds, 0)
		If Empty(nCPUCount) or This.CPUCount <= nCPUCount
			Debugout Time(0), Program(), nMilliseconds
			Sleep(nMilliseconds)
		EndIf 
	ENDPROC

	PROCEDURE startcriticalsection		&& Start Critical Section of code. Use a unique (but not random) name for each critical section.
		* Start Critical Section of code. Use a unique (but not random) name for each critical section.
		Lparameters cCriticalSectionName
		Local lnhMutex, lnHandleCount
		
		#DEFINE INFINITE 0xFFFFFFFF
		
		Debugout Time(0), Program(), cCriticalSectionName
		
		lnhMutex = CreateMutex(0, 0, cCriticalSectionName)
		
		* Wait for other processes to finish critical section
		WaitForSingleObject(lnhMutex, INFINITE)
		
		* Add handle to array so we can access it by name
		lnHandleCount = Alen(This._CriticalSections, 1)
		If lnHandleCount = 1 and Empty(This._CriticalSections[1,1])
			lnHandleCount = 1
		Else
			lnHandleCount = lnHandleCount + 1 
		EndIf 
		Dimension This._CriticalSections[lnHandleCount,2]
		This._CriticalSections[lnHandleCount,1] = cCriticalSectionName
		This._CriticalSections[lnHandleCount,2] = lnhMutex
		
	ENDPROC

	PROCEDURE updateprogress		&& Send progress update to main process. Pass .T. to llForceUpdate to disregard Worker.ProgressInterval.
		* Send progress update to main process
		* Pass .T. to llForceUpdate to disregard Worker.ProgressInterval.
		Lparameters nProgress, cMessage, lForceUpdate
		Local lnSeconds
		
		Debugout Time(0), Program(), nProgress, cMessage, lForceUpdate
		
		lnSeconds = Seconds() - This._LastProgressUpdate
		If lForceUpdate or lnSeconds < 0 or lnSeconds >= This.ProgressInterval
			If _Screen.oMainProcess.IsRunning() and Type("_Screen.oWorkerEvents.Name") = "C"
				_Screen.oWorkerEvents.UpdateProgress(nProgress, cMessage)
			EndIf 
			This._LastProgressUpdate = Seconds()
		EndIf 
		
	ENDPROC

ENDDEFINE

DEFINE CLASS workermgr AS amanager OF "parallelfox.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: call		&& Execute/call function on worker.
		*m: callmethod		&& Execute/call class method on worker.
		*m: do		&& Execute program on worker.
		*m: docmd		&& Execute single command on worker.
		*m: execscript		&& Execute script on worker.
		*m: processcommand		&& Process command.
		*m: sendcommand		&& Send command to worker process.
		*m: setmainprocess		&& Set reference to main process.
		*m: setworkerevents		&& Set reference to worker events object.
		*m: startmtcommandloop		&& Start command loop for MTDLL
		*p: ocmdtimer		&& Timer used to start command asynchronously.
		*p: ocommand		&& Command object.
	*</DefinedPropArrayMethod>

	Name = "workermgr"
	ocmdtimer = .NULL.		&& Timer used to start command asynchronously.
	ocommand = .NULL.		&& Command object.
	_memberdata = <VFPData>
		<memberdata name="deserializeparameters" display="DeserializeParameters"/>
		<memberdata name="instantiateipc" display="InstantiateIPC"/>
		<memberdata name="instantiatejson" display="InstantiateJSON"/>
		<memberdata name="processmessage" display="ProcessMessage"/>
		<memberdata name="registerworker" display="RegisterWorker"/>
		<memberdata name="hwndmain" display="hWndMain"/>
		<memberdata name="ocmdtimer" display="oCmdTimer"/>
		<memberdata name="processcommand" display="ProcessCommand"/>
		<memberdata name="ocommand" display="oCommand"/>
		<memberdata name="createcommandobject" display="CreateCommandObject"/>
		<memberdata name="execscript" display="ExecScript"/>
		<memberdata name="call" display="Call"/>
		<memberdata name="sendcommand" display="SendCommand"/>
		<memberdata name="docmd" display="DoCmd"/>
		<memberdata name="callmethod" display="CallMethod"/>
		<memberdata name="do" display="Do"/>
		<memberdata name="setmainprocess" display="SetMainProcess"/>
		<memberdata name="setworkerevents" display="SetWorkerEvents"/>
		<memberdata name="startmtcommandloop" display="StartMTCommandLoop"/>
		</VFPData>
	
	PROTECTED PROCEDURE call		&& Execute/call function on worker.
		* Execute/call function on worker
		Lparameters lcFunction, loParameters
		Local tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24, tPar25
		Local lcParameterClause, lcFunctionCall
		
		lcParameterClause = This.CreateParameterClause(loParameters, @tPar1, @tPar2, @tPar3, @tPar4, ;
			@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
			@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
			@tPar19, @tPar20, @tPar21, @tPar22, @tPar23, @tPar24, @tPar25)
		
		Debugout Time(0), Program(), lcFunction, lcParameterClause 
			
		lcFunctionCall = Alltrim(lcFunction)+ "(" + lcParameterClause + ")"
		Return &lcFunctionCall
		
		
	ENDPROC

	PROTECTED PROCEDURE callmethod		&& Execute/call class method on worker.
		* Execute/call class method on worker.
		Lparameters lcMethod, lcClassName, lcModule, lcInApplication, loParameters
		Local tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24, tPar25
		Local lcParameterClause, lcMethodCall, loObject
			
		lcParameterClause = This.CreateParameterClause(loParameters, @tPar1, @tPar2, @tPar3, @tPar4, ;
			@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
			@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
			@tPar19, @tPar20, @tPar21, @tPar22, @tPar23, @tPar24, @tPar25)
		
		Debugout Time(0), Program(), lcMethod, lcClassName, lcModule, lcInApplication, lcParameterClause 
			
		loObject = NewObject(lcClassName, lcModule, lcInApplication)
		lcMethodCall = Alltrim(lcMethod)+ "(" + lcParameterClause + ")"
		Return loObject.&lcMethodCall
		
		
	ENDPROC

	PROCEDURE Destroy
		* Make sure worker is closed
		Debugout Time(0), Program()
		
		If _VFP.StartMode <> 5
			Quit
		EndIf 
		
	ENDPROC

	PROTECTED PROCEDURE do		&& Execute program on worker.
		* Execute program on worker
		Lparameters lcPRG, lcInProgram, loParameters
		Local tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24, tPar25
		Local lcParameterClause
		
		If loParameters.nPCount > 0
			lcParameterClause = This.CreateParameterClause(loParameters, @tPar1, @tPar2, @tPar3, @tPar4, ;
				@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
				@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
				@tPar19, @tPar20, @tPar21, @tPar22, @tPar23, @tPar24, @tPar25)
			* DO passes all parameters by reference, so strip out "@" to avoid syntax error
			lcParameterClause = Chrtran(lcParameterClause, "@", "")
			Debugout Time(0), Program(), lcPRG, lcInProgram, lcParameterClause 	
			Do (lcPRG) in (lcInProgram) with &lcParameterClause
		Else 
			Debugout Time(0), Program(), lcPRG, lcInProgram
			Do (lcPRG) in (lcInProgram)
		EndIf 
		
		* No return value from DO command, so always .T.
	ENDPROC

	PROCEDURE docmd		&& Execute single command on worker.
		Lparameters lcCommand
		
		Debugout Time(0), Program(), lcCommand
		
		Return _VFP.DoCmd(lcCommand)
	ENDPROC

	PROTECTED PROCEDURE execscript		&& Execute script on worker.
		* Execute script on worker
		Lparameters lcScript, loParameters
		Local tPar1, tPar2, tPar3, tPar4, tPar5, tPar6, ;
			tPar7, tPar8, tPar9, tPar10, tPar11, tPar12, tPar13, ;
			tPar14, tPar15, tPar16, tPar17, tPar18, tPar19, tPar20, ;
			tPar21, tPar22, tPar23, tPar24, tPar25
		Local lcParameterClause
			
		If loParameters.nPCount > 0
			lcParameterClause = This.CreateParameterClause(loParameters, @tPar1, @tPar2, @tPar3, @tPar4, ;
				@tPar5, @tPar6, @tPar7, @tPar8, @tPar9, @tPar10, @tPar11, ;
				@tPar12, @tPar13, @tPar14, @tPar15, @tPar16, @tPar17, @tPar18, ;
				@tPar19, @tPar20, @tPar21, @tPar22, @tPar23, @tPar24, @tPar25)
			Debugout Time(0), Program(), "(Script)", lcParameterClause 
			Return ExecScript(lcScript, &lcParameterClause)
		Else
			Debugout Time(0), Program(), "(Script)"
			Return ExecScript(lcScript)
		EndIf 
		
		
	ENDPROC

	PROCEDURE Init
		_VFP.Caption = "ParallelFox Worker"
		* Set Unattended mode unless in debug mode
		* Make sure an error handler is in place on worker or displaying UI 
		*	can cause worker to crash.
		If _VFP.StartMode > 1
			Sys(2335,0)
			* Default error handler
			_Screen.NewObject("oErrorHandler", "ErrorHandler", "ParallelFox.vcx")
		EndIf 
		Set TablePrompt Off
		If _VFP.StartMode <> 5
			This.oCmdTimer = NewObject("tmrCommand", "ParallelFox.vcx")
		EndIf 
		
		Return DoDefault()
	ENDPROC

	PROCEDURE processcommand		&& Process command.
		* Process Command
		Local loCommand as Command of ParallelFox.vcx, lcCommandType, lvReturn
		loCommand = This.oCommand	&& for Intellisense
		
		Assert !IsNull(loCommand) Message Program() + " Command object is NULL"
		
		Debugout Time(0), Program(), loCommand.cCommandType, loCommand.cCommand, ;
			loCommand.cClass, loCommand.cModule
		
		lcCommandType = Upper(Alltrim(loCommand.cCommandType))
		Do Case
		Case lcCommandType == "DOCMD"
			lvReturn = This.DoCmd(loCommand.cCommand)
		Case lcCommandType == "DO"
			lvReturn = This.Do(loCommand.cCommand, loCommand.cClass, loCommand.oParameters)
		Case lcCommandType == "CALL"
			lvReturn = This.Call(loCommand.cCommand, loCommand.oParameters)
		Case lcCommandType == "CALLMETHOD"
			lvReturn = This.CallMethod(loCommand.cCommand, loCommand.cClass, loCommand.cModule, loCommand.cInApplication, loCommand.oParameters)
		Case lcCommandType == "EXECSCRIPT"
			lvReturn = This.ExecScript(loCommand.cCommand, loCommand.oParameters)
		Otherwise
		
		EndCase
		
		* Fire Complete event
		If _Screen.oMainProcess.IsRunning() and Type("_Screen.oWorkerEvents.Name") = "C"
			_Screen.oWorkerEvents.Complete(lvReturn)
		EndIf 
		
	ENDPROC

	PROCEDURE sendcommand		&& Send command to worker process.
		* Send command to worker
		Lparameters loCommand as Command of ParallelFox.vcx
		
		Debugout Time(0), Program(), loCommand.cCommandType, loCommand.cCommand, ;
			loCommand.cClass, loCommand.cModule
		
		This.oCommand = loCommand
		
		* Timer is used to start command without blocking main process
		This.oCmdTimer.ProcessCommand(This)
	ENDPROC

	PROCEDURE setmainprocess		&& Set reference to main process.
		* Set reference to main process.
		Lparameters loMainVFP, lcWorkerApp
		Local loMainProcess as MainProcess of ParallelFox.vcx
		
		If VarType(_Screen.oMainProcess) = "U"
			_Screen.AddProperty("oMainProcess", NULL)
		EndIf 
		
		loMainProcess = NewObject("MainProcess", This.ClassLibrary, lcWorkerApp)
		loMainProcess.oMainVFP = loMainVFP
		loMainProcess.StartTimer()
		_Screen.oMainProcess = loMainProcess
		
	ENDPROC

	PROCEDURE setworkerevents		&& Set reference to worker events object.
		* Set reference to worker events object.
		Lparameters loWorkerEvents
		
		If VarType(_Screen.oWorkerEvents) = "U"
			_Screen.AddProperty("oWorkerEvents", NULL)
		EndIf 
		
		_Screen.oWorkerEvents = loWorkerEvents
	ENDPROC

	PROCEDURE startmtcommandloop		&& Start command loop for MTDLL
		* Start command loop for MTDLL
		* When using MTDLL workers, the thread will shutdown as soon as program is complete
		* So, we have to use a loop to keep program alive and fetch commands from main thread.
		Lparameters loThreadHandler as ThreadHandler of ParallelFox.vcx
		Local lnEventHandle, lcScript, llExit, lnWaitStatus
		
		#DEFINE INFINITE 0xFFFFFFFF
		#DEFINE WAIT_TIMEOUT 0x00000102
		
		DECLARE INTEGER WaitForSingleObject IN kernel32;
		    INTEGER hHandle,;
		    INTEGER dwMilliseconds
		
		lnEventHandle = loThreadHandler.nEventHandle
		
		This.SetWorkerEvents(loThreadHandler.oEvents)
		
		llExit = .f.
		Do while .t.
			
			* Wait until main thread sends event that a command is ready to process
			lnWaitStatus = WaitForSingleObject(lnEventHandle, 10000)
			If lnWaitStatus <> 0
				* Zero means event fired
				* If timeout, check and see if proxy still good
				If lnWaitStatus = WAIT_TIMEOUT and Type("loThreadHandler.Name") = "C"
					Loop 
				Else 
					* Otherwise, something went wrong, so exit
					Exit 
				EndIf 
			EndIf 
		
			Try
				lcScript = loThreadHandler.cMTScript
				This.oCommand = loThreadHandler.oCommand
			Catch 
				* If can't access worker proxy object or commands, exit	
				llExit = .t.
			EndTry 	
			If llExit
				Exit
			EndIf 
			
			* Exit if stop workers command sent
			If Upper(lcScript) = "STOPWORKER"
				Exit 
			EndIf 
			
			* Process command
			This.ProcessCommand()
		
		EndDo 
		
		This.oCommand = NULL
		If VarType(_Screen.oMainProcess) = "O" and !IsNull(_Screen.oMainProcess)
			_Screen.oMainProcess.oMainVFP = NULL
			_Screen.oMainProcess = NULL
		EndIf 
		
		This.SetWorkerEvents(NULL)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS workerproxy AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: complete		&& Fires when worker has finished executing command.
		*m: handleerror		&& Fires when error returned from worker.
		*m: sendcommand		&& Send command to worker process.
		*m: stopworker		&& Stop worker process.
		*p: lbusy		&& Worker is busy processing command.
		*p: lcomplete		&& Is .T. when current command is complete, but lBusy is still .T. Worker will be released for another command when queue is processed.
		*p: ldebugmode		&& Start workers in Debug mode.
		*p: llocked		&& Is .T. when worker is locked to a specific command and was busy when command queue was processed.
		*p: lmtdll		&& Is .T. when using MTDLL workers.
		*p: nworkernum		&& Worker number.
		*p: oapplication		&& Reference to ParallelFox Application COM object.
		*p: oevents		&& Reference to worker events object.
		*p: othreadhandler		&& MTDLL Thread Handler.
		*p: oworker		&& Reference to Worker process.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED ldebugmode,lmtdll,oapplication,othreadhandler,oworker
	Height = 16
	lbusy = .F.		&& Worker is busy processing command.
	lcomplete = .F.		&& Is .T. when current command is complete, but lBusy is still .T. Worker will be released for another command when queue is processed.
	ldebugmode = .F.		&& Start workers in Debug mode.
	llocked = .F.		&& Is .T. when worker is locked to a specific command and was busy when command queue was processed.
	lmtdll = .F.		&& Is .T. when using MTDLL workers.
	Name = "workerproxy"
	nworkernum = 0		&& Worker number.
	oapplication = .NULL.		&& Reference to ParallelFox Application COM object.
	oevents = .NULL.		&& Reference to worker events object.
	othreadhandler = .NULL.		&& MTDLL Thread Handler.
	oworker = .NULL.		&& Reference to Worker process.
	Width = 99
	_memberdata = <VFPData>
		<memberdata name="lbusy" display="lBusy"/>
		<memberdata name="oworker" display="oWorker"/>
		<memberdata name="sendcommand" display="SendCommand"/>
		<memberdata name="complete" display="Complete"/>
		<memberdata name="llocked" display="lLocked"/>
		<memberdata name="ldebugmode" display="lDebugMode"/>
		<memberdata name="stopworker" display="StopWorker"/>
		<memberdata name="handleerror" display="HandleError"/>
		<memberdata name="oevents" display="oEvents"/>
		<memberdata name="oapplication" display="oApplication"/>
		<memberdata name="lcomplete" display="lComplete"/>
		<memberdata name="nworkernum" display="nWorkerNum"/>
		<memberdata name="lmtdll" display="lMTDLL"/>
		<memberdata name="othreadhandler" display="oThreadHandler"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE complete		&& Fires when worker has finished executing command.
		Lparameters lvReturn
		
		Debugout Time(0), "(" + Transform(This.nWorkerNum) + ")", Program(), lvReturn
		
		* Unbind command events and rebind events to this object
		UnBindEvents(This.oEvents)
		BindEvent(This.oEvents, "Complete", This, "Complete", 1)
		BindEvent(This.oEvents, "ReturnError", This, "HandleError", 1)
		
		This.lComplete = .t.
		*JAL*	This.lBusy = .f.
		*JAL*	_Screen.ParPoolMgr.nBusyWorkers = _Screen.ParPoolMgr.nBusyWorkers - 1 
		_Screen.ParPoolMgr.ProcessQueue()
		
	ENDPROC

	PROCEDURE Destroy
		Debugout Time(0), "(" + Transform(This.nWorkerNum) + ")", Program()
		
		If This.lMTDLL
		    This.StopWorker()
		EndIf 
		
		
	ENDPROC

	PROCEDURE handleerror		&& Fires when error returned from worker.
		Lparameters lnError, lcMethod, lnLine, lcMessage, lcCode
		
		Debugout Time(0), "(" + Transform(This.nWorkerNum) + ")", Program(), lnError, lcMethod, lnLine, lcMessage, lcCode
		
		This.Complete()
	ENDPROC

	PROCEDURE Init
		* Create worker process
		Lparameters lcProcedureFile, lcDirectory, llDebugMode, lnWorkerNum, llMTDLL
		Local lhWndForeground
		Local loVFP as VisualFoxPro.Application, lcWorkerVCX, lcWorkerAPP, lcWorkerCmd
		
		Debugout Time(0), "(" + Transform(lnWorkerNum) + ")", Program(), lcProcedureFile, lcDirectory, llDebugMode, llMTDLL
		
		This.lMTDLL = llMTDLL
		
		* In Windows XP and earlier, main process can lose focus when 
		*	instantiating COM EXE. Make sure we keep it.
		DECLARE INTEGER GetForegroundWindow IN user32
		lhWndForeground = GetForegroundWindow()
		
		This.nWorkerNum = lnWorkerNum
		* Debug mode starts workers in full VFP.
		If llDebugMode and _VFP.StartMode = 0
			loVFP = CreateObject("VisualFoxPro.Application." + SUBSTR(VERSION(4),2,1))
			loVFP.Visible = .t.
			This.lDebugMode = .t.
			This.lMTDLL = .f.
		Else 
			* Must maintain reference to Application object, or COM instance will close even though we also 
			*	have reference to Worker object.
			If !This.lMTDLL
				This.oApplication = CreateObject("ParallelFox.Application")
				loVFP = This.oApplication.VFP
			EndIf 
		 	lcWorkerVCX = FullPath(_Screen.ParPoolMgr.cWorkerLibrary)
		*JAL*		This.oWorker = CreateObject(_Screen.ParPoolMgr.cWorkerCOMProgID)
		EndIf 
		* ParallelFox.vcx is compiled into APP/EXE
		If InList(Upper(JustExt(lcProcedureFile)), "APP", "EXE")
			lcWorkerApp = FullPath(lcProcedureFile)
		Else 
			lcWorkerApp = ""
		EndIf 
		
		* Set up worker events
		This.oEvents = NewObject("Events", "ParallelFox.vcx")
		This.oEvents.Name = "WorkerProxyEvents"	&& to distinguish object from other events objects during debugging
		BindEvent(This.oEvents, "Complete", This, "Complete", 1)
		BindEvent(This.oEvents, "ReturnError", This, "HandleError", 1)
		
		lcDirectory = ["] + Evl(lcDirectory, FullPath("")) + ["]
		lcProcedureFile = Evl(lcProcedureFile, "")
		If This.lMTDLL
			* Multi-threaded DLL
			Local loThreadHandler as ThreadHandler of ParallelFox.vcx
			loThreadHandler = NewObject("ThreadHandler", "ParallelFox.vcx")
			This.oThreadHandler = loThreadHandler
			loThreadHandler.oEvents = This.oEvents
			loThreadHandler.StartThread(lcDirectory, lcWorkerVCX, lcWorkerApp, lcProcedureFile)
		Else 
			lcWorkerVCX = FullPath(_Screen.ParPoolMgr.cWorkerLibrary)
			If Directory(JustPath(lcWorkerVCX))
				loVFP.DoCmd([CD "] + JustPath(lcWorkerVCX) + ["])
			EndIf 
			lcWorkerCmd = Textmerge([NewObject("<<_Screen.ParPoolMgr.cWorkerClass>>", "<<lcWorkerVCX>>", "<<lcWorkerApp>>")])
			This.oWorker = loVFP.Eval(lcWorkerCmd)
		
			* In Windows XP and earlier, main process can lose focus when 
			*	instantiating COM EXE. Make sure we keep it.
			* This issue apparently only affects IDE, and can cause wrong window 
			*	to get focus at runtime if workers started when main VFP window is not visible.
			*	So, only applying to IDE.  May revisit if issue presents itself at runtime or other scenarios.
			If _VFP.StartMode = 0 and Os(3) < "6" and GetForegroundWindow() <> lhWndForeground
				DECLARE INTEGER SetForegroundWindow IN user32 INTEGER hwnd
				SetForegroundWindow(lhWndForeground)
			EndIf
		
			This.oWorker.SetMainProcess(_VFP, lcWorkerApp)
			This.oWorker.DoCmd("CD " + lcDirectory)
			If !Empty(lcProcedureFile)
				lcProcedureFile = ["] + lcProcedureFile + ["]
				This.oWorker.DoCmd("Set Procedure To " + lcProcedureFile + " Additive")
			EndIf 
			This.oWorker.SetWorkerEvents(This.oEvents)
		EndIf 
		
	ENDPROC

	PROCEDURE sendcommand		&& Send command to worker process.
		* Send command to worker process.
		Lparameters loCommand as Command of ParallelFox.vcx
		
		Debugout Time(0), "(" + Transform(This.nWorkerNum) + ")", Program(), loCommand.cCommandType, loCommand.cCommand, ;
			loCommand.cClass, loCommand.cModule
		
		* Make sure events objects are in same data session
		This.oEvents.SetDataSession(loCommand.oEvents.GetDataSession())
		
		* Bind events to current event object
		BindEvent(This.oEvents, "Complete", loCommand.oEvents, "Complete")
		BindEvent(This.oEvents, "ReturnError", loCommand.oEvents, "ReturnError")
		BindEvent(This.oEvents, "ReturnData", loCommand.oEvents, "ReturnData")
		BindEvent(This.oEvents, "UpdateProgress", loCommand.oEvents, "UpdateProgress")
		BindEvent(This.oEvents, "ReturnCursor", loCommand.oEvents, "ReturnCursor")
		
		If This.lMTDLL
			This.oThreadHandler.SendCommand(loCommand)
		Else 
			This.oWorker.SendCommand(loCommand)
		EndIf 
		
	ENDPROC

	PROCEDURE stopworker		&& Stop worker process.
		Debugout Time(0), "(" + Transform(This.nWorkerNum) + ")", Program()
		
		This.oWorker = NULL
		This.oApplication = NULL
		
		If This.lMTDLL
			If Vartype(This.oThreadHandler) = "O" and !IsNull(This.oThreadHandler)
				This.oThreadHandler.StopThread()
				This.oThreadHandler = NULL
			EndIf 
		EndIf 
		
	ENDPROC

ENDDEFINE
